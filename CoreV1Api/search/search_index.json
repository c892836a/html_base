{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"kubernetes.client.CoreV1Api All URIs are relative to http://localhost Method HTTP request Description connect_delete_namespaced_pod_proxy DELETE /api/v1/namespaces/{namespace}/pods/{name}/proxy connect_delete_namespaced_pod_proxy_with_path DELETE /api/v1/namespaces/{namespace}/pods/{name}/proxy/{path} connect_delete_namespaced_service_proxy DELETE /api/v1/namespaces/{namespace}/services/{name}/proxy connect_delete_namespaced_service_proxy_with_path DELETE /api/v1/namespaces/{namespace}/services/{name}/proxy/{path} connect_delete_node_proxy DELETE /api/v1/nodes/{name}/proxy connect_delete_node_proxy_with_path DELETE /api/v1/nodes/{name}/proxy/{path} connect_get_namespaced_pod_attach GET /api/v1/namespaces/{namespace}/pods/{name}/attach connect_get_namespaced_pod_exec GET /api/v1/namespaces/{namespace}/pods/{name}/exec connect_get_namespaced_pod_portforward GET /api/v1/namespaces/{namespace}/pods/{name}/portforward connect_get_namespaced_pod_proxy GET /api/v1/namespaces/{namespace}/pods/{name}/proxy connect_get_namespaced_pod_proxy_with_path GET /api/v1/namespaces/{namespace}/pods/{name}/proxy/{path} connect_get_namespaced_service_proxy GET /api/v1/namespaces/{namespace}/services/{name}/proxy connect_get_namespaced_service_proxy_with_path GET /api/v1/namespaces/{namespace}/services/{name}/proxy/{path} connect_get_node_proxy GET /api/v1/nodes/{name}/proxy connect_get_node_proxy_with_path GET /api/v1/nodes/{name}/proxy/{path} connect_head_namespaced_pod_proxy HEAD /api/v1/namespaces/{namespace}/pods/{name}/proxy connect_head_namespaced_pod_proxy_with_path HEAD /api/v1/namespaces/{namespace}/pods/{name}/proxy/{path} connect_head_namespaced_service_proxy HEAD /api/v1/namespaces/{namespace}/services/{name}/proxy connect_head_namespaced_service_proxy_with_path HEAD /api/v1/namespaces/{namespace}/services/{name}/proxy/{path} connect_head_node_proxy HEAD /api/v1/nodes/{name}/proxy connect_head_node_proxy_with_path HEAD /api/v1/nodes/{name}/proxy/{path} connect_options_namespaced_pod_proxy OPTIONS /api/v1/namespaces/{namespace}/pods/{name}/proxy connect_options_namespaced_pod_proxy_with_path OPTIONS /api/v1/namespaces/{namespace}/pods/{name}/proxy/{path} connect_options_namespaced_service_proxy OPTIONS /api/v1/namespaces/{namespace}/services/{name}/proxy connect_options_namespaced_service_proxy_with_path OPTIONS /api/v1/namespaces/{namespace}/services/{name}/proxy/{path} connect_options_node_proxy OPTIONS /api/v1/nodes/{name}/proxy connect_options_node_proxy_with_path OPTIONS /api/v1/nodes/{name}/proxy/{path} connect_patch_namespaced_pod_proxy PATCH /api/v1/namespaces/{namespace}/pods/{name}/proxy connect_patch_namespaced_pod_proxy_with_path PATCH /api/v1/namespaces/{namespace}/pods/{name}/proxy/{path} connect_patch_namespaced_service_proxy PATCH /api/v1/namespaces/{namespace}/services/{name}/proxy connect_patch_namespaced_service_proxy_with_path PATCH /api/v1/namespaces/{namespace}/services/{name}/proxy/{path} connect_patch_node_proxy PATCH /api/v1/nodes/{name}/proxy connect_patch_node_proxy_with_path PATCH /api/v1/nodes/{name}/proxy/{path} connect_post_namespaced_pod_attach POST /api/v1/namespaces/{namespace}/pods/{name}/attach connect_post_namespaced_pod_exec POST /api/v1/namespaces/{namespace}/pods/{name}/exec connect_post_namespaced_pod_portforward POST /api/v1/namespaces/{namespace}/pods/{name}/portforward connect_post_namespaced_pod_proxy POST /api/v1/namespaces/{namespace}/pods/{name}/proxy connect_post_namespaced_pod_proxy_with_path POST /api/v1/namespaces/{namespace}/pods/{name}/proxy/{path} connect_post_namespaced_service_proxy POST /api/v1/namespaces/{namespace}/services/{name}/proxy connect_post_namespaced_service_proxy_with_path POST /api/v1/namespaces/{namespace}/services/{name}/proxy/{path} connect_post_node_proxy POST /api/v1/nodes/{name}/proxy connect_post_node_proxy_with_path POST /api/v1/nodes/{name}/proxy/{path} connect_put_namespaced_pod_proxy PUT /api/v1/namespaces/{namespace}/pods/{name}/proxy connect_put_namespaced_pod_proxy_with_path PUT /api/v1/namespaces/{namespace}/pods/{name}/proxy/{path} connect_put_namespaced_service_proxy PUT /api/v1/namespaces/{namespace}/services/{name}/proxy connect_put_namespaced_service_proxy_with_path PUT /api/v1/namespaces/{namespace}/services/{name}/proxy/{path} connect_put_node_proxy PUT /api/v1/nodes/{name}/proxy connect_put_node_proxy_with_path PUT /api/v1/nodes/{name}/proxy/{path} create_namespace POST /api/v1/namespaces create_namespaced_binding POST /api/v1/namespaces/{namespace}/bindings create_namespaced_config_map POST /api/v1/namespaces/{namespace}/configmaps create_namespaced_endpoints POST /api/v1/namespaces/{namespace}/endpoints create_namespaced_event POST /api/v1/namespaces/{namespace}/events create_namespaced_limit_range POST /api/v1/namespaces/{namespace}/limitranges create_namespaced_persistent_volume_claim POST /api/v1/namespaces/{namespace}/persistentvolumeclaims create_namespaced_pod POST /api/v1/namespaces/{namespace}/pods create_namespaced_pod_binding POST /api/v1/namespaces/{namespace}/pods/{name}/binding create_namespaced_pod_eviction POST /api/v1/namespaces/{namespace}/pods/{name}/eviction create_namespaced_pod_template POST /api/v1/namespaces/{namespace}/podtemplates create_namespaced_replication_controller POST /api/v1/namespaces/{namespace}/replicationcontrollers create_namespaced_resource_quota POST /api/v1/namespaces/{namespace}/resourcequotas create_namespaced_secret POST /api/v1/namespaces/{namespace}/secrets create_namespaced_service POST /api/v1/namespaces/{namespace}/services create_namespaced_service_account POST /api/v1/namespaces/{namespace}/serviceaccounts create_namespaced_service_account_token POST /api/v1/namespaces/{namespace}/serviceaccounts/{name}/token create_node POST /api/v1/nodes create_persistent_volume POST /api/v1/persistentvolumes delete_collection_namespaced_config_map DELETE /api/v1/namespaces/{namespace}/configmaps delete_collection_namespaced_endpoints DELETE /api/v1/namespaces/{namespace}/endpoints delete_collection_namespaced_event DELETE /api/v1/namespaces/{namespace}/events delete_collection_namespaced_limit_range DELETE /api/v1/namespaces/{namespace}/limitranges delete_collection_namespaced_persistent_volume_claim DELETE /api/v1/namespaces/{namespace}/persistentvolumeclaims delete_collection_namespaced_pod DELETE /api/v1/namespaces/{namespace}/pods delete_collection_namespaced_pod_template DELETE /api/v1/namespaces/{namespace}/podtemplates delete_collection_namespaced_replication_controller DELETE /api/v1/namespaces/{namespace}/replicationcontrollers delete_collection_namespaced_resource_quota DELETE /api/v1/namespaces/{namespace}/resourcequotas delete_collection_namespaced_secret DELETE /api/v1/namespaces/{namespace}/secrets delete_collection_namespaced_service_account DELETE /api/v1/namespaces/{namespace}/serviceaccounts delete_collection_node DELETE /api/v1/nodes delete_collection_persistent_volume DELETE /api/v1/persistentvolumes delete_namespace DELETE /api/v1/namespaces/{name} delete_namespaced_config_map DELETE /api/v1/namespaces/{namespace}/configmaps/{name} delete_namespaced_endpoints DELETE /api/v1/namespaces/{namespace}/endpoints/{name} delete_namespaced_event DELETE /api/v1/namespaces/{namespace}/events/{name} delete_namespaced_limit_range DELETE /api/v1/namespaces/{namespace}/limitranges/{name} delete_namespaced_persistent_volume_claim DELETE /api/v1/namespaces/{namespace}/persistentvolumeclaims/{name} delete_namespaced_pod DELETE /api/v1/namespaces/{namespace}/pods/{name} delete_namespaced_pod_template DELETE /api/v1/namespaces/{namespace}/podtemplates/{name} delete_namespaced_replication_controller DELETE /api/v1/namespaces/{namespace}/replicationcontrollers/{name} delete_namespaced_resource_quota DELETE /api/v1/namespaces/{namespace}/resourcequotas/{name} delete_namespaced_secret DELETE /api/v1/namespaces/{namespace}/secrets/{name} delete_namespaced_service DELETE /api/v1/namespaces/{namespace}/services/{name} delete_namespaced_service_account DELETE /api/v1/namespaces/{namespace}/serviceaccounts/{name} delete_node DELETE /api/v1/nodes/{name} delete_persistent_volume DELETE /api/v1/persistentvolumes/{name} get_api_resources GET /api/v1/ list_component_status GET /api/v1/componentstatuses list_config_map_for_all_namespaces GET /api/v1/configmaps list_endpoints_for_all_namespaces GET /api/v1/endpoints list_event_for_all_namespaces GET /api/v1/events list_limit_range_for_all_namespaces GET /api/v1/limitranges list_namespace GET /api/v1/namespaces list_namespaced_config_map GET /api/v1/namespaces/{namespace}/configmaps list_namespaced_endpoints GET /api/v1/namespaces/{namespace}/endpoints list_namespaced_event GET /api/v1/namespaces/{namespace}/events list_namespaced_limit_range GET /api/v1/namespaces/{namespace}/limitranges list_namespaced_persistent_volume_claim GET /api/v1/namespaces/{namespace}/persistentvolumeclaims list_namespaced_pod GET /api/v1/namespaces/{namespace}/pods list_namespaced_pod_template GET /api/v1/namespaces/{namespace}/podtemplates list_namespaced_replication_controller GET /api/v1/namespaces/{namespace}/replicationcontrollers list_namespaced_resource_quota GET /api/v1/namespaces/{namespace}/resourcequotas list_namespaced_secret GET /api/v1/namespaces/{namespace}/secrets list_namespaced_service GET /api/v1/namespaces/{namespace}/services list_namespaced_service_account GET /api/v1/namespaces/{namespace}/serviceaccounts list_node GET /api/v1/nodes list_persistent_volume GET /api/v1/persistentvolumes list_persistent_volume_claim_for_all_namespaces GET /api/v1/persistentvolumeclaims list_pod_for_all_namespaces GET /api/v1/pods list_pod_template_for_all_namespaces GET /api/v1/podtemplates list_replication_controller_for_all_namespaces GET /api/v1/replicationcontrollers list_resource_quota_for_all_namespaces GET /api/v1/resourcequotas list_secret_for_all_namespaces GET /api/v1/secrets list_service_account_for_all_namespaces GET /api/v1/serviceaccounts list_service_for_all_namespaces GET /api/v1/services patch_namespace PATCH /api/v1/namespaces/{name} patch_namespace_status PATCH /api/v1/namespaces/{name}/status patch_namespaced_config_map PATCH /api/v1/namespaces/{namespace}/configmaps/{name} patch_namespaced_endpoints PATCH /api/v1/namespaces/{namespace}/endpoints/{name} patch_namespaced_event PATCH /api/v1/namespaces/{namespace}/events/{name} patch_namespaced_limit_range PATCH /api/v1/namespaces/{namespace}/limitranges/{name} patch_namespaced_persistent_volume_claim PATCH /api/v1/namespaces/{namespace}/persistentvolumeclaims/{name} patch_namespaced_persistent_volume_claim_status PATCH /api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status patch_namespaced_pod PATCH /api/v1/namespaces/{namespace}/pods/{name} patch_namespaced_pod_status PATCH /api/v1/namespaces/{namespace}/pods/{name}/status patch_namespaced_pod_template PATCH /api/v1/namespaces/{namespace}/podtemplates/{name} patch_namespaced_replication_controller PATCH /api/v1/namespaces/{namespace}/replicationcontrollers/{name} patch_namespaced_replication_controller_scale PATCH /api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale patch_namespaced_replication_controller_status PATCH /api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status patch_namespaced_resource_quota PATCH /api/v1/namespaces/{namespace}/resourcequotas/{name} patch_namespaced_resource_quota_status PATCH /api/v1/namespaces/{namespace}/resourcequotas/{name}/status patch_namespaced_secret PATCH /api/v1/namespaces/{namespace}/secrets/{name} patch_namespaced_service PATCH /api/v1/namespaces/{namespace}/services/{name} patch_namespaced_service_account PATCH /api/v1/namespaces/{namespace}/serviceaccounts/{name} patch_namespaced_service_status PATCH /api/v1/namespaces/{namespace}/services/{name}/status patch_node PATCH /api/v1/nodes/{name} patch_node_status PATCH /api/v1/nodes/{name}/status patch_persistent_volume PATCH /api/v1/persistentvolumes/{name} patch_persistent_volume_status PATCH /api/v1/persistentvolumes/{name}/status read_component_status GET /api/v1/componentstatuses/{name} read_namespace GET /api/v1/namespaces/{name} read_namespace_status GET /api/v1/namespaces/{name}/status read_namespaced_config_map GET /api/v1/namespaces/{namespace}/configmaps/{name} read_namespaced_endpoints GET /api/v1/namespaces/{namespace}/endpoints/{name} read_namespaced_event GET /api/v1/namespaces/{namespace}/events/{name} read_namespaced_limit_range GET /api/v1/namespaces/{namespace}/limitranges/{name} read_namespaced_persistent_volume_claim GET /api/v1/namespaces/{namespace}/persistentvolumeclaims/{name} read_namespaced_persistent_volume_claim_status GET /api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status read_namespaced_pod GET /api/v1/namespaces/{namespace}/pods/{name} read_namespaced_pod_log GET /api/v1/namespaces/{namespace}/pods/{name}/log read_namespaced_pod_status GET /api/v1/namespaces/{namespace}/pods/{name}/status read_namespaced_pod_template GET /api/v1/namespaces/{namespace}/podtemplates/{name} read_namespaced_replication_controller GET /api/v1/namespaces/{namespace}/replicationcontrollers/{name} read_namespaced_replication_controller_scale GET /api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale read_namespaced_replication_controller_status GET /api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status read_namespaced_resource_quota GET /api/v1/namespaces/{namespace}/resourcequotas/{name} read_namespaced_resource_quota_status GET /api/v1/namespaces/{namespace}/resourcequotas/{name}/status read_namespaced_secret GET /api/v1/namespaces/{namespace}/secrets/{name} read_namespaced_service GET /api/v1/namespaces/{namespace}/services/{name} read_namespaced_service_account GET /api/v1/namespaces/{namespace}/serviceaccounts/{name} read_namespaced_service_status GET /api/v1/namespaces/{namespace}/services/{name}/status read_node GET /api/v1/nodes/{name} read_node_status GET /api/v1/nodes/{name}/status read_persistent_volume GET /api/v1/persistentvolumes/{name} read_persistent_volume_status GET /api/v1/persistentvolumes/{name}/status replace_namespace PUT /api/v1/namespaces/{name} replace_namespace_finalize PUT /api/v1/namespaces/{name}/finalize replace_namespace_status PUT /api/v1/namespaces/{name}/status replace_namespaced_config_map PUT /api/v1/namespaces/{namespace}/configmaps/{name} replace_namespaced_endpoints PUT /api/v1/namespaces/{namespace}/endpoints/{name} replace_namespaced_event PUT /api/v1/namespaces/{namespace}/events/{name} replace_namespaced_limit_range PUT /api/v1/namespaces/{namespace}/limitranges/{name} replace_namespaced_persistent_volume_claim PUT /api/v1/namespaces/{namespace}/persistentvolumeclaims/{name} replace_namespaced_persistent_volume_claim_status PUT /api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status replace_namespaced_pod PUT /api/v1/namespaces/{namespace}/pods/{name} replace_namespaced_pod_status PUT /api/v1/namespaces/{namespace}/pods/{name}/status replace_namespaced_pod_template PUT /api/v1/namespaces/{namespace}/podtemplates/{name} replace_namespaced_replication_controller PUT /api/v1/namespaces/{namespace}/replicationcontrollers/{name} replace_namespaced_replication_controller_scale PUT /api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale replace_namespaced_replication_controller_status PUT /api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status replace_namespaced_resource_quota PUT /api/v1/namespaces/{namespace}/resourcequotas/{name} replace_namespaced_resource_quota_status PUT /api/v1/namespaces/{namespace}/resourcequotas/{name}/status replace_namespaced_secret PUT /api/v1/namespaces/{namespace}/secrets/{name} replace_namespaced_service PUT /api/v1/namespaces/{namespace}/services/{name} replace_namespaced_service_account PUT /api/v1/namespaces/{namespace}/serviceaccounts/{name} replace_namespaced_service_status PUT /api/v1/namespaces/{namespace}/services/{name}/status replace_node PUT /api/v1/nodes/{name} replace_node_status PUT /api/v1/nodes/{name}/status replace_persistent_volume PUT /api/v1/persistentvolumes/{name} replace_persistent_volume_status PUT /api/v1/persistentvolumes/{name}/status connect_delete_namespaced_pod_proxy str connect_delete_namespaced_pod_proxy(name, namespace, path=path) connect DELETE requests to proxy of Pod Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | Path is the URL path to use for the current proxy request to pod. (optional) try: api_response = api_instance.connect_delete_namespaced_pod_proxy(name, namespace, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_delete_namespaced_pod_proxy: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PodProxyOptions namespace str object name and auth scope, such as for teams and projects path str Path is the URL path to use for the current proxy request to pod. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_delete_namespaced_pod_proxy_with_path str connect_delete_namespaced_pod_proxy_with_path(name, namespace, path, path2=path2) connect DELETE requests to proxy of Pod Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the URL path to use for the current proxy request to pod. (optional) try: api_response = api_instance.connect_delete_namespaced_pod_proxy_with_path(name, namespace, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_delete_namespaced_pod_proxy_with_path: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PodProxyOptions namespace str object name and auth scope, such as for teams and projects path str path to the resource path2 str Path is the URL path to use for the current proxy request to pod. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_delete_namespaced_service_proxy str connect_delete_namespaced_service_proxy(name, namespace, path=path) connect DELETE requests to proxy of Service Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. (optional) try: api_response = api_instance.connect_delete_namespaced_service_proxy(name, namespace, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_delete_namespaced_service_proxy: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ServiceProxyOptions namespace str object name and auth scope, such as for teams and projects path str Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_delete_namespaced_service_proxy_with_path str connect_delete_namespaced_service_proxy_with_path(name, namespace, path, path2=path2) connect DELETE requests to proxy of Service Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. (optional) try: api_response = api_instance.connect_delete_namespaced_service_proxy_with_path(name, namespace, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_delete_namespaced_service_proxy_with_path: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ServiceProxyOptions namespace str object name and auth scope, such as for teams and projects path str path to the resource path2 str Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_delete_node_proxy str connect_delete_node_proxy(name, path=path) connect DELETE requests to proxy of Node Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the NodeProxyOptions path = 'path_example' # str | Path is the URL path to use for the current proxy request to node. (optional) try: api_response = api_instance.connect_delete_node_proxy(name, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_delete_node_proxy: %s\\n\" % e) Parameters Name Type Description Notes name str name of the NodeProxyOptions path str Path is the URL path to use for the current proxy request to node. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_delete_node_proxy_with_path str connect_delete_node_proxy_with_path(name, path, path2=path2) connect DELETE requests to proxy of Node Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the NodeProxyOptions path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the URL path to use for the current proxy request to node. (optional) try: api_response = api_instance.connect_delete_node_proxy_with_path(name, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_delete_node_proxy_with_path: %s\\n\" % e) Parameters Name Type Description Notes name str name of the NodeProxyOptions path str path to the resource path2 str Path is the URL path to use for the current proxy request to node. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_get_namespaced_pod_attach str connect_get_namespaced_pod_attach(name, namespace, container=container, stderr=stderr, stdin=stdin, stdout=stdout, tty=tty) connect GET requests to attach of Pod Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodAttachOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects container = 'container_example' # str | The container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional) stderr = True # bool | Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true. (optional) stdin = True # bool | Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false. (optional) stdout = True # bool | Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true. (optional) tty = True # bool | TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false. (optional) try: api_response = api_instance.connect_get_namespaced_pod_attach(name, namespace, container=container, stderr=stderr, stdin=stdin, stdout=stdout, tty=tty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_get_namespaced_pod_attach: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PodAttachOptions namespace str object name and auth scope, such as for teams and projects container str The container in which to execute the command. Defaults to only container if there is only one container in the pod. [optional] stderr bool Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true. [optional] stdin bool Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false. [optional] stdout bool Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true. [optional] tty bool TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_get_namespaced_pod_exec str connect_get_namespaced_pod_exec(name, namespace, command=command, container=container, stderr=stderr, stdin=stdin, stdout=stdout, tty=tty) connect GET requests to exec of Pod Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodExecOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects command = 'command_example' # str | Command is the remote command to execute. argv array. Not executed within a shell. (optional) container = 'container_example' # str | Container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional) stderr = True # bool | Redirect the standard error stream of the pod for this call. Defaults to true. (optional) stdin = True # bool | Redirect the standard input stream of the pod for this call. Defaults to false. (optional) stdout = True # bool | Redirect the standard output stream of the pod for this call. Defaults to true. (optional) tty = True # bool | TTY if true indicates that a tty will be allocated for the exec call. Defaults to false. (optional) try: api_response = api_instance.connect_get_namespaced_pod_exec(name, namespace, command=command, container=container, stderr=stderr, stdin=stdin, stdout=stdout, tty=tty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_get_namespaced_pod_exec: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PodExecOptions namespace str object name and auth scope, such as for teams and projects command str Command is the remote command to execute. argv array. Not executed within a shell. [optional] container str Container in which to execute the command. Defaults to only container if there is only one container in the pod. [optional] stderr bool Redirect the standard error stream of the pod for this call. Defaults to true. [optional] stdin bool Redirect the standard input stream of the pod for this call. Defaults to false. [optional] stdout bool Redirect the standard output stream of the pod for this call. Defaults to true. [optional] tty bool TTY if true indicates that a tty will be allocated for the exec call. Defaults to false. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_get_namespaced_pod_portforward str connect_get_namespaced_pod_portforward(name, namespace, ports=ports) connect GET requests to portforward of Pod Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodPortForwardOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects ports = 56 # int | List of ports to forward Required when using WebSockets (optional) try: api_response = api_instance.connect_get_namespaced_pod_portforward(name, namespace, ports=ports) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_get_namespaced_pod_portforward: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PodPortForwardOptions namespace str object name and auth scope, such as for teams and projects ports int List of ports to forward Required when using WebSockets [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_get_namespaced_pod_proxy str connect_get_namespaced_pod_proxy(name, namespace, path=path) connect GET requests to proxy of Pod Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | Path is the URL path to use for the current proxy request to pod. (optional) try: api_response = api_instance.connect_get_namespaced_pod_proxy(name, namespace, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_get_namespaced_pod_proxy: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PodProxyOptions namespace str object name and auth scope, such as for teams and projects path str Path is the URL path to use for the current proxy request to pod. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_get_namespaced_pod_proxy_with_path str connect_get_namespaced_pod_proxy_with_path(name, namespace, path, path2=path2) connect GET requests to proxy of Pod Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the URL path to use for the current proxy request to pod. (optional) try: api_response = api_instance.connect_get_namespaced_pod_proxy_with_path(name, namespace, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_get_namespaced_pod_proxy_with_path: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PodProxyOptions namespace str object name and auth scope, such as for teams and projects path str path to the resource path2 str Path is the URL path to use for the current proxy request to pod. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_get_namespaced_service_proxy str connect_get_namespaced_service_proxy(name, namespace, path=path) connect GET requests to proxy of Service Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. (optional) try: api_response = api_instance.connect_get_namespaced_service_proxy(name, namespace, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_get_namespaced_service_proxy: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ServiceProxyOptions namespace str object name and auth scope, such as for teams and projects path str Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_get_namespaced_service_proxy_with_path str connect_get_namespaced_service_proxy_with_path(name, namespace, path, path2=path2) connect GET requests to proxy of Service Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. (optional) try: api_response = api_instance.connect_get_namespaced_service_proxy_with_path(name, namespace, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_get_namespaced_service_proxy_with_path: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ServiceProxyOptions namespace str object name and auth scope, such as for teams and projects path str path to the resource path2 str Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_get_node_proxy str connect_get_node_proxy(name, path=path) connect GET requests to proxy of Node Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the NodeProxyOptions path = 'path_example' # str | Path is the URL path to use for the current proxy request to node. (optional) try: api_response = api_instance.connect_get_node_proxy(name, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_get_node_proxy: %s\\n\" % e) Parameters Name Type Description Notes name str name of the NodeProxyOptions path str Path is the URL path to use for the current proxy request to node. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_get_node_proxy_with_path str connect_get_node_proxy_with_path(name, path, path2=path2) connect GET requests to proxy of Node Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the NodeProxyOptions path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the URL path to use for the current proxy request to node. (optional) try: api_response = api_instance.connect_get_node_proxy_with_path(name, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_get_node_proxy_with_path: %s\\n\" % e) Parameters Name Type Description Notes name str name of the NodeProxyOptions path str path to the resource path2 str Path is the URL path to use for the current proxy request to node. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_head_namespaced_pod_proxy str connect_head_namespaced_pod_proxy(name, namespace, path=path) connect HEAD requests to proxy of Pod Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | Path is the URL path to use for the current proxy request to pod. (optional) try: api_response = api_instance.connect_head_namespaced_pod_proxy(name, namespace, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_head_namespaced_pod_proxy: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PodProxyOptions namespace str object name and auth scope, such as for teams and projects path str Path is the URL path to use for the current proxy request to pod. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_head_namespaced_pod_proxy_with_path str connect_head_namespaced_pod_proxy_with_path(name, namespace, path, path2=path2) connect HEAD requests to proxy of Pod Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the URL path to use for the current proxy request to pod. (optional) try: api_response = api_instance.connect_head_namespaced_pod_proxy_with_path(name, namespace, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_head_namespaced_pod_proxy_with_path: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PodProxyOptions namespace str object name and auth scope, such as for teams and projects path str path to the resource path2 str Path is the URL path to use for the current proxy request to pod. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_head_namespaced_service_proxy str connect_head_namespaced_service_proxy(name, namespace, path=path) connect HEAD requests to proxy of Service Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. (optional) try: api_response = api_instance.connect_head_namespaced_service_proxy(name, namespace, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_head_namespaced_service_proxy: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ServiceProxyOptions namespace str object name and auth scope, such as for teams and projects path str Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_head_namespaced_service_proxy_with_path str connect_head_namespaced_service_proxy_with_path(name, namespace, path, path2=path2) connect HEAD requests to proxy of Service Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. (optional) try: api_response = api_instance.connect_head_namespaced_service_proxy_with_path(name, namespace, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_head_namespaced_service_proxy_with_path: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ServiceProxyOptions namespace str object name and auth scope, such as for teams and projects path str path to the resource path2 str Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_head_node_proxy str connect_head_node_proxy(name, path=path) connect HEAD requests to proxy of Node Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the NodeProxyOptions path = 'path_example' # str | Path is the URL path to use for the current proxy request to node. (optional) try: api_response = api_instance.connect_head_node_proxy(name, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_head_node_proxy: %s\\n\" % e) Parameters Name Type Description Notes name str name of the NodeProxyOptions path str Path is the URL path to use for the current proxy request to node. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_head_node_proxy_with_path str connect_head_node_proxy_with_path(name, path, path2=path2) connect HEAD requests to proxy of Node Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the NodeProxyOptions path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the URL path to use for the current proxy request to node. (optional) try: api_response = api_instance.connect_head_node_proxy_with_path(name, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_head_node_proxy_with_path: %s\\n\" % e) Parameters Name Type Description Notes name str name of the NodeProxyOptions path str path to the resource path2 str Path is the URL path to use for the current proxy request to node. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_options_namespaced_pod_proxy str connect_options_namespaced_pod_proxy(name, namespace, path=path) connect OPTIONS requests to proxy of Pod Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | Path is the URL path to use for the current proxy request to pod. (optional) try: api_response = api_instance.connect_options_namespaced_pod_proxy(name, namespace, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_options_namespaced_pod_proxy: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PodProxyOptions namespace str object name and auth scope, such as for teams and projects path str Path is the URL path to use for the current proxy request to pod. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_options_namespaced_pod_proxy_with_path str connect_options_namespaced_pod_proxy_with_path(name, namespace, path, path2=path2) connect OPTIONS requests to proxy of Pod Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the URL path to use for the current proxy request to pod. (optional) try: api_response = api_instance.connect_options_namespaced_pod_proxy_with_path(name, namespace, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_options_namespaced_pod_proxy_with_path: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PodProxyOptions namespace str object name and auth scope, such as for teams and projects path str path to the resource path2 str Path is the URL path to use for the current proxy request to pod. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_options_namespaced_service_proxy str connect_options_namespaced_service_proxy(name, namespace, path=path) connect OPTIONS requests to proxy of Service Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. (optional) try: api_response = api_instance.connect_options_namespaced_service_proxy(name, namespace, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_options_namespaced_service_proxy: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ServiceProxyOptions namespace str object name and auth scope, such as for teams and projects path str Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_options_namespaced_service_proxy_with_path str connect_options_namespaced_service_proxy_with_path(name, namespace, path, path2=path2) connect OPTIONS requests to proxy of Service Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. (optional) try: api_response = api_instance.connect_options_namespaced_service_proxy_with_path(name, namespace, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_options_namespaced_service_proxy_with_path: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ServiceProxyOptions namespace str object name and auth scope, such as for teams and projects path str path to the resource path2 str Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_options_node_proxy str connect_options_node_proxy(name, path=path) connect OPTIONS requests to proxy of Node Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the NodeProxyOptions path = 'path_example' # str | Path is the URL path to use for the current proxy request to node. (optional) try: api_response = api_instance.connect_options_node_proxy(name, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_options_node_proxy: %s\\n\" % e) Parameters Name Type Description Notes name str name of the NodeProxyOptions path str Path is the URL path to use for the current proxy request to node. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_options_node_proxy_with_path str connect_options_node_proxy_with_path(name, path, path2=path2) connect OPTIONS requests to proxy of Node Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the NodeProxyOptions path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the URL path to use for the current proxy request to node. (optional) try: api_response = api_instance.connect_options_node_proxy_with_path(name, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_options_node_proxy_with_path: %s\\n\" % e) Parameters Name Type Description Notes name str name of the NodeProxyOptions path str path to the resource path2 str Path is the URL path to use for the current proxy request to node. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_patch_namespaced_pod_proxy str connect_patch_namespaced_pod_proxy(name, namespace, path=path) connect PATCH requests to proxy of Pod Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | Path is the URL path to use for the current proxy request to pod. (optional) try: api_response = api_instance.connect_patch_namespaced_pod_proxy(name, namespace, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_patch_namespaced_pod_proxy: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PodProxyOptions namespace str object name and auth scope, such as for teams and projects path str Path is the URL path to use for the current proxy request to pod. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_patch_namespaced_pod_proxy_with_path str connect_patch_namespaced_pod_proxy_with_path(name, namespace, path, path2=path2) connect PATCH requests to proxy of Pod Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the URL path to use for the current proxy request to pod. (optional) try: api_response = api_instance.connect_patch_namespaced_pod_proxy_with_path(name, namespace, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_patch_namespaced_pod_proxy_with_path: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PodProxyOptions namespace str object name and auth scope, such as for teams and projects path str path to the resource path2 str Path is the URL path to use for the current proxy request to pod. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_patch_namespaced_service_proxy str connect_patch_namespaced_service_proxy(name, namespace, path=path) connect PATCH requests to proxy of Service Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. (optional) try: api_response = api_instance.connect_patch_namespaced_service_proxy(name, namespace, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_patch_namespaced_service_proxy: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ServiceProxyOptions namespace str object name and auth scope, such as for teams and projects path str Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_patch_namespaced_service_proxy_with_path str connect_patch_namespaced_service_proxy_with_path(name, namespace, path, path2=path2) connect PATCH requests to proxy of Service Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. (optional) try: api_response = api_instance.connect_patch_namespaced_service_proxy_with_path(name, namespace, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_patch_namespaced_service_proxy_with_path: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ServiceProxyOptions namespace str object name and auth scope, such as for teams and projects path str path to the resource path2 str Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_patch_node_proxy str connect_patch_node_proxy(name, path=path) connect PATCH requests to proxy of Node Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the NodeProxyOptions path = 'path_example' # str | Path is the URL path to use for the current proxy request to node. (optional) try: api_response = api_instance.connect_patch_node_proxy(name, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_patch_node_proxy: %s\\n\" % e) Parameters Name Type Description Notes name str name of the NodeProxyOptions path str Path is the URL path to use for the current proxy request to node. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_patch_node_proxy_with_path str connect_patch_node_proxy_with_path(name, path, path2=path2) connect PATCH requests to proxy of Node Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the NodeProxyOptions path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the URL path to use for the current proxy request to node. (optional) try: api_response = api_instance.connect_patch_node_proxy_with_path(name, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_patch_node_proxy_with_path: %s\\n\" % e) Parameters Name Type Description Notes name str name of the NodeProxyOptions path str path to the resource path2 str Path is the URL path to use for the current proxy request to node. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_post_namespaced_pod_attach str connect_post_namespaced_pod_attach(name, namespace, container=container, stderr=stderr, stdin=stdin, stdout=stdout, tty=tty) connect POST requests to attach of Pod Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodAttachOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects container = 'container_example' # str | The container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional) stderr = True # bool | Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true. (optional) stdin = True # bool | Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false. (optional) stdout = True # bool | Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true. (optional) tty = True # bool | TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false. (optional) try: api_response = api_instance.connect_post_namespaced_pod_attach(name, namespace, container=container, stderr=stderr, stdin=stdin, stdout=stdout, tty=tty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_post_namespaced_pod_attach: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PodAttachOptions namespace str object name and auth scope, such as for teams and projects container str The container in which to execute the command. Defaults to only container if there is only one container in the pod. [optional] stderr bool Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true. [optional] stdin bool Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false. [optional] stdout bool Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true. [optional] tty bool TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_post_namespaced_pod_exec str connect_post_namespaced_pod_exec(name, namespace, command=command, container=container, stderr=stderr, stdin=stdin, stdout=stdout, tty=tty) connect POST requests to exec of Pod Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodExecOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects command = 'command_example' # str | Command is the remote command to execute. argv array. Not executed within a shell. (optional) container = 'container_example' # str | Container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional) stderr = True # bool | Redirect the standard error stream of the pod for this call. Defaults to true. (optional) stdin = True # bool | Redirect the standard input stream of the pod for this call. Defaults to false. (optional) stdout = True # bool | Redirect the standard output stream of the pod for this call. Defaults to true. (optional) tty = True # bool | TTY if true indicates that a tty will be allocated for the exec call. Defaults to false. (optional) try: api_response = api_instance.connect_post_namespaced_pod_exec(name, namespace, command=command, container=container, stderr=stderr, stdin=stdin, stdout=stdout, tty=tty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_post_namespaced_pod_exec: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PodExecOptions namespace str object name and auth scope, such as for teams and projects command str Command is the remote command to execute. argv array. Not executed within a shell. [optional] container str Container in which to execute the command. Defaults to only container if there is only one container in the pod. [optional] stderr bool Redirect the standard error stream of the pod for this call. Defaults to true. [optional] stdin bool Redirect the standard input stream of the pod for this call. Defaults to false. [optional] stdout bool Redirect the standard output stream of the pod for this call. Defaults to true. [optional] tty bool TTY if true indicates that a tty will be allocated for the exec call. Defaults to false. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_post_namespaced_pod_portforward str connect_post_namespaced_pod_portforward(name, namespace, ports=ports) connect POST requests to portforward of Pod Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodPortForwardOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects ports = 56 # int | List of ports to forward Required when using WebSockets (optional) try: api_response = api_instance.connect_post_namespaced_pod_portforward(name, namespace, ports=ports) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_post_namespaced_pod_portforward: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PodPortForwardOptions namespace str object name and auth scope, such as for teams and projects ports int List of ports to forward Required when using WebSockets [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_post_namespaced_pod_proxy str connect_post_namespaced_pod_proxy(name, namespace, path=path) connect POST requests to proxy of Pod Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | Path is the URL path to use for the current proxy request to pod. (optional) try: api_response = api_instance.connect_post_namespaced_pod_proxy(name, namespace, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_post_namespaced_pod_proxy: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PodProxyOptions namespace str object name and auth scope, such as for teams and projects path str Path is the URL path to use for the current proxy request to pod. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_post_namespaced_pod_proxy_with_path str connect_post_namespaced_pod_proxy_with_path(name, namespace, path, path2=path2) connect POST requests to proxy of Pod Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the URL path to use for the current proxy request to pod. (optional) try: api_response = api_instance.connect_post_namespaced_pod_proxy_with_path(name, namespace, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_post_namespaced_pod_proxy_with_path: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PodProxyOptions namespace str object name and auth scope, such as for teams and projects path str path to the resource path2 str Path is the URL path to use for the current proxy request to pod. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_post_namespaced_service_proxy str connect_post_namespaced_service_proxy(name, namespace, path=path) connect POST requests to proxy of Service Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. (optional) try: api_response = api_instance.connect_post_namespaced_service_proxy(name, namespace, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_post_namespaced_service_proxy: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ServiceProxyOptions namespace str object name and auth scope, such as for teams and projects path str Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_post_namespaced_service_proxy_with_path str connect_post_namespaced_service_proxy_with_path(name, namespace, path, path2=path2) connect POST requests to proxy of Service Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. (optional) try: api_response = api_instance.connect_post_namespaced_service_proxy_with_path(name, namespace, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_post_namespaced_service_proxy_with_path: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ServiceProxyOptions namespace str object name and auth scope, such as for teams and projects path str path to the resource path2 str Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_post_node_proxy str connect_post_node_proxy(name, path=path) connect POST requests to proxy of Node Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the NodeProxyOptions path = 'path_example' # str | Path is the URL path to use for the current proxy request to node. (optional) try: api_response = api_instance.connect_post_node_proxy(name, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_post_node_proxy: %s\\n\" % e) Parameters Name Type Description Notes name str name of the NodeProxyOptions path str Path is the URL path to use for the current proxy request to node. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_post_node_proxy_with_path str connect_post_node_proxy_with_path(name, path, path2=path2) connect POST requests to proxy of Node Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the NodeProxyOptions path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the URL path to use for the current proxy request to node. (optional) try: api_response = api_instance.connect_post_node_proxy_with_path(name, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_post_node_proxy_with_path: %s\\n\" % e) Parameters Name Type Description Notes name str name of the NodeProxyOptions path str path to the resource path2 str Path is the URL path to use for the current proxy request to node. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_put_namespaced_pod_proxy str connect_put_namespaced_pod_proxy(name, namespace, path=path) connect PUT requests to proxy of Pod Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | Path is the URL path to use for the current proxy request to pod. (optional) try: api_response = api_instance.connect_put_namespaced_pod_proxy(name, namespace, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_put_namespaced_pod_proxy: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PodProxyOptions namespace str object name and auth scope, such as for teams and projects path str Path is the URL path to use for the current proxy request to pod. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_put_namespaced_pod_proxy_with_path str connect_put_namespaced_pod_proxy_with_path(name, namespace, path, path2=path2) connect PUT requests to proxy of Pod Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the URL path to use for the current proxy request to pod. (optional) try: api_response = api_instance.connect_put_namespaced_pod_proxy_with_path(name, namespace, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_put_namespaced_pod_proxy_with_path: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PodProxyOptions namespace str object name and auth scope, such as for teams and projects path str path to the resource path2 str Path is the URL path to use for the current proxy request to pod. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_put_namespaced_service_proxy str connect_put_namespaced_service_proxy(name, namespace, path=path) connect PUT requests to proxy of Service Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. (optional) try: api_response = api_instance.connect_put_namespaced_service_proxy(name, namespace, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_put_namespaced_service_proxy: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ServiceProxyOptions namespace str object name and auth scope, such as for teams and projects path str Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_put_namespaced_service_proxy_with_path str connect_put_namespaced_service_proxy_with_path(name, namespace, path, path2=path2) connect PUT requests to proxy of Service Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. (optional) try: api_response = api_instance.connect_put_namespaced_service_proxy_with_path(name, namespace, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_put_namespaced_service_proxy_with_path: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ServiceProxyOptions namespace str object name and auth scope, such as for teams and projects path str path to the resource path2 str Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_put_node_proxy str connect_put_node_proxy(name, path=path) connect PUT requests to proxy of Node Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the NodeProxyOptions path = 'path_example' # str | Path is the URL path to use for the current proxy request to node. (optional) try: api_response = api_instance.connect_put_node_proxy(name, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_put_node_proxy: %s\\n\" % e) Parameters Name Type Description Notes name str name of the NodeProxyOptions path str Path is the URL path to use for the current proxy request to node. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] connect_put_node_proxy_with_path str connect_put_node_proxy_with_path(name, path, path2=path2) connect PUT requests to proxy of Node Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the NodeProxyOptions path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the URL path to use for the current proxy request to node. (optional) try: api_response = api_instance.connect_put_node_proxy_with_path(name, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_put_node_proxy_with_path: %s\\n\" % e) Parameters Name Type Description Notes name str name of the NodeProxyOptions path str path to the resource path2 str Path is the URL path to use for the current proxy request to node. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : / HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] create_namespace V1Namespace create_namespace(body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) create a Namespace Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) body = kubernetes.client.V1Namespace() # V1Namespace | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.create_namespace(body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_namespace: %s\\n\" % e) Parameters Name Type Description Notes body V1Namespace pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1Namespace Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] create_namespaced_binding V1Binding create_namespaced_binding(namespace, body, dry_run=dry_run, field_manager=field_manager, pretty=pretty) create a Binding Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1Binding() # V1Binding | dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) try: api_response = api_instance.create_namespaced_binding(namespace, body, dry_run=dry_run, field_manager=field_manager, pretty=pretty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_namespaced_binding: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects body V1Binding dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] pretty str If 'true', then the output is pretty printed. [optional] Return type V1Binding Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] create_namespaced_config_map V1ConfigMap create_namespaced_config_map(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) create a ConfigMap Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1ConfigMap() # V1ConfigMap | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.create_namespaced_config_map(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_namespaced_config_map: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects body V1ConfigMap pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1ConfigMap Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] create_namespaced_endpoints V1Endpoints create_namespaced_endpoints(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) create Endpoints Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1Endpoints() # V1Endpoints | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.create_namespaced_endpoints(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_namespaced_endpoints: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects body V1Endpoints pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1Endpoints Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] create_namespaced_event V1Event create_namespaced_event(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) create an Event Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1Event() # V1Event | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.create_namespaced_event(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_namespaced_event: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects body V1Event pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1Event Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] create_namespaced_limit_range V1LimitRange create_namespaced_limit_range(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) create a LimitRange Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1LimitRange() # V1LimitRange | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.create_namespaced_limit_range(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_namespaced_limit_range: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects body V1LimitRange pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1LimitRange Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] create_namespaced_persistent_volume_claim V1PersistentVolumeClaim create_namespaced_persistent_volume_claim(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) create a PersistentVolumeClaim Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1PersistentVolumeClaim() # V1PersistentVolumeClaim | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.create_namespaced_persistent_volume_claim(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_namespaced_persistent_volume_claim: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects body V1PersistentVolumeClaim pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1PersistentVolumeClaim Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] create_namespaced_pod V1Pod create_namespaced_pod(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) create a Pod Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1Pod() # V1Pod | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.create_namespaced_pod(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_namespaced_pod: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects body V1Pod pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1Pod Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] create_namespaced_pod_binding V1Binding create_namespaced_pod_binding(name, namespace, body, dry_run=dry_run, field_manager=field_manager, pretty=pretty) create binding of a Pod Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Binding namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1Binding() # V1Binding | dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) try: api_response = api_instance.create_namespaced_pod_binding(name, namespace, body, dry_run=dry_run, field_manager=field_manager, pretty=pretty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_namespaced_pod_binding: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Binding namespace str object name and auth scope, such as for teams and projects body V1Binding dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] pretty str If 'true', then the output is pretty printed. [optional] Return type V1Binding Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] create_namespaced_pod_eviction V1beta1Eviction create_namespaced_pod_eviction(name, namespace, body, dry_run=dry_run, field_manager=field_manager, pretty=pretty) create eviction of a Pod Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Eviction namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1beta1Eviction() # V1beta1Eviction | dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) try: api_response = api_instance.create_namespaced_pod_eviction(name, namespace, body, dry_run=dry_run, field_manager=field_manager, pretty=pretty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_namespaced_pod_eviction: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Eviction namespace str object name and auth scope, such as for teams and projects body V1beta1Eviction dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] pretty str If 'true', then the output is pretty printed. [optional] Return type V1beta1Eviction Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] create_namespaced_pod_template V1PodTemplate create_namespaced_pod_template(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) create a PodTemplate Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1PodTemplate() # V1PodTemplate | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.create_namespaced_pod_template(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_namespaced_pod_template: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects body V1PodTemplate pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1PodTemplate Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] create_namespaced_replication_controller V1ReplicationController create_namespaced_replication_controller(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) create a ReplicationController Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1ReplicationController() # V1ReplicationController | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.create_namespaced_replication_controller(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_namespaced_replication_controller: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects body V1ReplicationController pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1ReplicationController Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] create_namespaced_resource_quota V1ResourceQuota create_namespaced_resource_quota(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) create a ResourceQuota Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1ResourceQuota() # V1ResourceQuota | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.create_namespaced_resource_quota(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_namespaced_resource_quota: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects body V1ResourceQuota pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1ResourceQuota Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] create_namespaced_secret V1Secret create_namespaced_secret(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) create a Secret Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1Secret() # V1Secret | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.create_namespaced_secret(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_namespaced_secret: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects body V1Secret pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1Secret Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] create_namespaced_service V1Service create_namespaced_service(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) create a Service Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1Service() # V1Service | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.create_namespaced_service(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_namespaced_service: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects body V1Service pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1Service Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] create_namespaced_service_account V1ServiceAccount create_namespaced_service_account(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) create a ServiceAccount Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1ServiceAccount() # V1ServiceAccount | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.create_namespaced_service_account(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_namespaced_service_account: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects body V1ServiceAccount pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1ServiceAccount Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] create_namespaced_service_account_token V1TokenRequest create_namespaced_service_account_token(name, namespace, body, dry_run=dry_run, field_manager=field_manager, pretty=pretty) create token of a ServiceAccount Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the TokenRequest namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1TokenRequest() # V1TokenRequest | dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) try: api_response = api_instance.create_namespaced_service_account_token(name, namespace, body, dry_run=dry_run, field_manager=field_manager, pretty=pretty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_namespaced_service_account_token: %s\\n\" % e) Parameters Name Type Description Notes name str name of the TokenRequest namespace str object name and auth scope, such as for teams and projects body V1TokenRequest dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] pretty str If 'true', then the output is pretty printed. [optional] Return type V1TokenRequest Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] create_node V1Node create_node(body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) create a Node Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) body = kubernetes.client.V1Node() # V1Node | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.create_node(body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_node: %s\\n\" % e) Parameters Name Type Description Notes body V1Node pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1Node Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] create_persistent_volume V1PersistentVolume create_persistent_volume(body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) create a PersistentVolume Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) body = kubernetes.client.V1PersistentVolume() # V1PersistentVolume | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.create_persistent_volume(body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_persistent_volume: %s\\n\" % e) Parameters Name Type Description Notes body V1PersistentVolume pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1PersistentVolume Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] delete_collection_namespaced_config_map V1Status delete_collection_namespaced_config_map(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) delete collection of ConfigMap Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_collection_namespaced_config_map(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_collection_namespaced_config_map: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] body V1DeleteOptions [optional] Return type V1Status Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] delete_collection_namespaced_endpoints V1Status delete_collection_namespaced_endpoints(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) delete collection of Endpoints Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_collection_namespaced_endpoints(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_collection_namespaced_endpoints: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] body V1DeleteOptions [optional] Return type V1Status Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] delete_collection_namespaced_event V1Status delete_collection_namespaced_event(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) delete collection of Event Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_collection_namespaced_event(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_collection_namespaced_event: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] body V1DeleteOptions [optional] Return type V1Status Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] delete_collection_namespaced_limit_range V1Status delete_collection_namespaced_limit_range(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) delete collection of LimitRange Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_collection_namespaced_limit_range(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_collection_namespaced_limit_range: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] body V1DeleteOptions [optional] Return type V1Status Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] delete_collection_namespaced_persistent_volume_claim V1Status delete_collection_namespaced_persistent_volume_claim(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) delete collection of PersistentVolumeClaim Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_collection_namespaced_persistent_volume_claim(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_collection_namespaced_persistent_volume_claim: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] body V1DeleteOptions [optional] Return type V1Status Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] delete_collection_namespaced_pod V1Status delete_collection_namespaced_pod(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) delete collection of Pod Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_collection_namespaced_pod(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_collection_namespaced_pod: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] body V1DeleteOptions [optional] Return type V1Status Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] delete_collection_namespaced_pod_template V1Status delete_collection_namespaced_pod_template(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) delete collection of PodTemplate Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_collection_namespaced_pod_template(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_collection_namespaced_pod_template: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] body V1DeleteOptions [optional] Return type V1Status Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] delete_collection_namespaced_replication_controller V1Status delete_collection_namespaced_replication_controller(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) delete collection of ReplicationController Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_collection_namespaced_replication_controller(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_collection_namespaced_replication_controller: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] body V1DeleteOptions [optional] Return type V1Status Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] delete_collection_namespaced_resource_quota V1Status delete_collection_namespaced_resource_quota(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) delete collection of ResourceQuota Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_collection_namespaced_resource_quota(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_collection_namespaced_resource_quota: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] body V1DeleteOptions [optional] Return type V1Status Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] delete_collection_namespaced_secret V1Status delete_collection_namespaced_secret(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) delete collection of Secret Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_collection_namespaced_secret(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_collection_namespaced_secret: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] body V1DeleteOptions [optional] Return type V1Status Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] delete_collection_namespaced_service_account V1Status delete_collection_namespaced_service_account(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) delete collection of ServiceAccount Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_collection_namespaced_service_account(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_collection_namespaced_service_account: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] body V1DeleteOptions [optional] Return type V1Status Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] delete_collection_node V1Status delete_collection_node(pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) delete collection of Node Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_collection_node(pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_collection_node: %s\\n\" % e) Parameters Name Type Description Notes pretty str If 'true', then the output is pretty printed. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] body V1DeleteOptions [optional] Return type V1Status Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] delete_collection_persistent_volume V1Status delete_collection_persistent_volume(pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) delete collection of PersistentVolume Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_collection_persistent_volume(pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_collection_persistent_volume: %s\\n\" % e) Parameters Name Type Description Notes pretty str If 'true', then the output is pretty printed. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] body V1DeleteOptions [optional] Return type V1Status Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] delete_namespace V1Status delete_namespace(name, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) delete a Namespace Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Namespace pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_namespace(name, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_namespace: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Namespace pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] body V1DeleteOptions [optional] Return type V1Status Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] delete_namespaced_config_map V1Status delete_namespaced_config_map(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) delete a ConfigMap Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ConfigMap namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_namespaced_config_map(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_namespaced_config_map: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ConfigMap namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] body V1DeleteOptions [optional] Return type V1Status Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] delete_namespaced_endpoints V1Status delete_namespaced_endpoints(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) delete Endpoints Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Endpoints namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_namespaced_endpoints(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_namespaced_endpoints: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Endpoints namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] body V1DeleteOptions [optional] Return type V1Status Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] delete_namespaced_event V1Status delete_namespaced_event(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) delete an Event Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Event namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_namespaced_event(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_namespaced_event: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Event namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] body V1DeleteOptions [optional] Return type V1Status Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] delete_namespaced_limit_range V1Status delete_namespaced_limit_range(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) delete a LimitRange Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the LimitRange namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_namespaced_limit_range(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_namespaced_limit_range: %s\\n\" % e) Parameters Name Type Description Notes name str name of the LimitRange namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] body V1DeleteOptions [optional] Return type V1Status Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] delete_namespaced_persistent_volume_claim V1Status delete_namespaced_persistent_volume_claim(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) delete a PersistentVolumeClaim Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PersistentVolumeClaim namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_namespaced_persistent_volume_claim(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_namespaced_persistent_volume_claim: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PersistentVolumeClaim namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] body V1DeleteOptions [optional] Return type V1Status Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] delete_namespaced_pod V1Status delete_namespaced_pod(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) delete a Pod Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Pod namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_namespaced_pod(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_namespaced_pod: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Pod namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] body V1DeleteOptions [optional] Return type V1Status Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] delete_namespaced_pod_template V1Status delete_namespaced_pod_template(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) delete a PodTemplate Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodTemplate namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_namespaced_pod_template(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_namespaced_pod_template: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PodTemplate namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] body V1DeleteOptions [optional] Return type V1Status Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] delete_namespaced_replication_controller V1Status delete_namespaced_replication_controller(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) delete a ReplicationController Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ReplicationController namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_namespaced_replication_controller(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_namespaced_replication_controller: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ReplicationController namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] body V1DeleteOptions [optional] Return type V1Status Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] delete_namespaced_resource_quota V1Status delete_namespaced_resource_quota(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) delete a ResourceQuota Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ResourceQuota namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_namespaced_resource_quota(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_namespaced_resource_quota: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ResourceQuota namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] body V1DeleteOptions [optional] Return type V1Status Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] delete_namespaced_secret V1Status delete_namespaced_secret(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) delete a Secret Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Secret namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_namespaced_secret(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_namespaced_secret: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Secret namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] body V1DeleteOptions [optional] Return type V1Status Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] delete_namespaced_service V1Status delete_namespaced_service(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) delete a Service Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Service namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_namespaced_service(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_namespaced_service: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Service namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] body V1DeleteOptions [optional] Return type V1Status Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] delete_namespaced_service_account V1Status delete_namespaced_service_account(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) delete a ServiceAccount Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceAccount namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_namespaced_service_account(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_namespaced_service_account: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ServiceAccount namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] body V1DeleteOptions [optional] Return type V1Status Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] delete_node V1Status delete_node(name, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) delete a Node Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Node pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_node(name, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_node: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Node pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] body V1DeleteOptions [optional] Return type V1Status Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] delete_persistent_volume V1Status delete_persistent_volume(name, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) delete a PersistentVolume Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PersistentVolume pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_persistent_volume(name, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_persistent_volume: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PersistentVolume pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] body V1DeleteOptions [optional] Return type V1Status Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] get_api_resources V1APIResourceList get_api_resources() get available resources Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) try: api_response = api_instance.get_api_resources() pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->get_api_resources: %s\\n\" % e) Parameters This endpoint does not need any parameter. Return type V1APIResourceList Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] list_component_status V1ComponentStatusList list_component_status(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list objects of kind ComponentStatus Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_component_status(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_component_status: %s\\n\" % e) Parameters Name Type Description Notes allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] pretty str If 'true', then the output is pretty printed. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional] Return type V1ComponentStatusList Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] list_config_map_for_all_namespaces V1ConfigMapList list_config_map_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind ConfigMap Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_config_map_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_config_map_for_all_namespaces: %s\\n\" % e) Parameters Name Type Description Notes allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] pretty str If 'true', then the output is pretty printed. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional] Return type V1ConfigMapList Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] list_endpoints_for_all_namespaces V1EndpointsList list_endpoints_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind Endpoints Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_endpoints_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_endpoints_for_all_namespaces: %s\\n\" % e) Parameters Name Type Description Notes allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] pretty str If 'true', then the output is pretty printed. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional] Return type V1EndpointsList Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] list_event_for_all_namespaces V1EventList list_event_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind Event Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_event_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_event_for_all_namespaces: %s\\n\" % e) Parameters Name Type Description Notes allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] pretty str If 'true', then the output is pretty printed. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional] Return type V1EventList Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] list_limit_range_for_all_namespaces V1LimitRangeList list_limit_range_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind LimitRange Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_limit_range_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_limit_range_for_all_namespaces: %s\\n\" % e) Parameters Name Type Description Notes allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] pretty str If 'true', then the output is pretty printed. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional] Return type V1LimitRangeList Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] list_namespace V1NamespaceList list_namespace(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind Namespace Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_namespace(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_namespace: %s\\n\" % e) Parameters Name Type Description Notes pretty str If 'true', then the output is pretty printed. [optional] allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional] Return type V1NamespaceList Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] list_namespaced_config_map V1ConfigMapList list_namespaced_config_map(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind ConfigMap Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_namespaced_config_map(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_namespaced_config_map: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional] Return type V1ConfigMapList Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] list_namespaced_endpoints V1EndpointsList list_namespaced_endpoints(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind Endpoints Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_namespaced_endpoints(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_namespaced_endpoints: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional] Return type V1EndpointsList Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] list_namespaced_event V1EventList list_namespaced_event(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind Event Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_namespaced_event(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_namespaced_event: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional] Return type V1EventList Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] list_namespaced_limit_range V1LimitRangeList list_namespaced_limit_range(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind LimitRange Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_namespaced_limit_range(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_namespaced_limit_range: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional] Return type V1LimitRangeList Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] list_namespaced_persistent_volume_claim V1PersistentVolumeClaimList list_namespaced_persistent_volume_claim(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind PersistentVolumeClaim Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_namespaced_persistent_volume_claim(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_namespaced_persistent_volume_claim: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional] Return type V1PersistentVolumeClaimList Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] list_namespaced_pod V1PodList list_namespaced_pod(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind Pod Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_namespaced_pod(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_namespaced_pod: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional] Return type V1PodList Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] list_namespaced_pod_template V1PodTemplateList list_namespaced_pod_template(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind PodTemplate Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_namespaced_pod_template(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_namespaced_pod_template: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional] Return type V1PodTemplateList Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] list_namespaced_replication_controller V1ReplicationControllerList list_namespaced_replication_controller(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind ReplicationController Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_namespaced_replication_controller(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_namespaced_replication_controller: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional] Return type V1ReplicationControllerList Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] list_namespaced_resource_quota V1ResourceQuotaList list_namespaced_resource_quota(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind ResourceQuota Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_namespaced_resource_quota(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_namespaced_resource_quota: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional] Return type V1ResourceQuotaList Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] list_namespaced_secret V1SecretList list_namespaced_secret(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind Secret Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_namespaced_secret(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_namespaced_secret: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional] Return type V1SecretList Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] list_namespaced_service V1ServiceList list_namespaced_service(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind Service Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_namespaced_service(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_namespaced_service: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional] Return type V1ServiceList Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] list_namespaced_service_account V1ServiceAccountList list_namespaced_service_account(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind ServiceAccount Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_namespaced_service_account(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_namespaced_service_account: %s\\n\" % e) Parameters Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional] Return type V1ServiceAccountList Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] list_node V1NodeList list_node(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind Node Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_node(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_node: %s\\n\" % e) Parameters Name Type Description Notes pretty str If 'true', then the output is pretty printed. [optional] allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional] Return type V1NodeList Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] list_persistent_volume V1PersistentVolumeList list_persistent_volume(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind PersistentVolume Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_persistent_volume(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_persistent_volume: %s\\n\" % e) Parameters Name Type Description Notes pretty str If 'true', then the output is pretty printed. [optional] allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional] Return type V1PersistentVolumeList Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] list_persistent_volume_claim_for_all_namespaces V1PersistentVolumeClaimList list_persistent_volume_claim_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind PersistentVolumeClaim Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_persistent_volume_claim_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_persistent_volume_claim_for_all_namespaces: %s\\n\" % e) Parameters Name Type Description Notes allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] pretty str If 'true', then the output is pretty printed. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional] Return type V1PersistentVolumeClaimList Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] list_pod_for_all_namespaces V1PodList list_pod_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind Pod Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_pod_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_pod_for_all_namespaces: %s\\n\" % e) Parameters Name Type Description Notes allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] pretty str If 'true', then the output is pretty printed. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional] Return type V1PodList Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] list_pod_template_for_all_namespaces V1PodTemplateList list_pod_template_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind PodTemplate Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_pod_template_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_pod_template_for_all_namespaces: %s\\n\" % e) Parameters Name Type Description Notes allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] pretty str If 'true', then the output is pretty printed. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional] Return type V1PodTemplateList Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] list_replication_controller_for_all_namespaces V1ReplicationControllerList list_replication_controller_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind ReplicationController Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_replication_controller_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_replication_controller_for_all_namespaces: %s\\n\" % e) Parameters Name Type Description Notes allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] pretty str If 'true', then the output is pretty printed. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional] Return type V1ReplicationControllerList Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] list_resource_quota_for_all_namespaces V1ResourceQuotaList list_resource_quota_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind ResourceQuota Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_resource_quota_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_resource_quota_for_all_namespaces: %s\\n\" % e) Parameters Name Type Description Notes allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] pretty str If 'true', then the output is pretty printed. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional] Return type V1ResourceQuotaList Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] list_secret_for_all_namespaces V1SecretList list_secret_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind Secret Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_secret_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_secret_for_all_namespaces: %s\\n\" % e) Parameters Name Type Description Notes allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] pretty str If 'true', then the output is pretty printed. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional] Return type V1SecretList Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] list_service_account_for_all_namespaces V1ServiceAccountList list_service_account_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind ServiceAccount Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_service_account_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_service_account_for_all_namespaces: %s\\n\" % e) Parameters Name Type Description Notes allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] pretty str If 'true', then the output is pretty printed. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional] Return type V1ServiceAccountList Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] list_service_for_all_namespaces V1ServiceList list_service_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind Service Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_service_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_service_for_all_namespaces: %s\\n\" % e) Parameters Name Type Description Notes allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] pretty str If 'true', then the output is pretty printed. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional] Return type V1ServiceList Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] patch_namespace V1Namespace patch_namespace(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update the specified Namespace Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Namespace body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespace(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespace: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Namespace body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional] Return type V1Namespace Authorization BearerToken HTTP request headers Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] patch_namespace_status V1Namespace patch_namespace_status(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update status of the specified Namespace Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Namespace body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespace_status(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespace_status: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Namespace body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional] Return type V1Namespace Authorization BearerToken HTTP request headers Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] patch_namespaced_config_map V1ConfigMap patch_namespaced_config_map(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update the specified ConfigMap Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ConfigMap namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_config_map(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_config_map: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ConfigMap namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional] Return type V1ConfigMap Authorization BearerToken HTTP request headers Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] patch_namespaced_endpoints V1Endpoints patch_namespaced_endpoints(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update the specified Endpoints Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Endpoints namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_endpoints(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_endpoints: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Endpoints namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional] Return type V1Endpoints Authorization BearerToken HTTP request headers Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] patch_namespaced_event V1Event patch_namespaced_event(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update the specified Event Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Event namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_event(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_event: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Event namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional] Return type V1Event Authorization BearerToken HTTP request headers Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] patch_namespaced_limit_range V1LimitRange patch_namespaced_limit_range(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update the specified LimitRange Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the LimitRange namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_limit_range(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_limit_range: %s\\n\" % e) Parameters Name Type Description Notes name str name of the LimitRange namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional] Return type V1LimitRange Authorization BearerToken HTTP request headers Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] patch_namespaced_persistent_volume_claim V1PersistentVolumeClaim patch_namespaced_persistent_volume_claim(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update the specified PersistentVolumeClaim Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PersistentVolumeClaim namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_persistent_volume_claim(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_persistent_volume_claim: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PersistentVolumeClaim namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional] Return type V1PersistentVolumeClaim Authorization BearerToken HTTP request headers Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] patch_namespaced_persistent_volume_claim_status V1PersistentVolumeClaim patch_namespaced_persistent_volume_claim_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update status of the specified PersistentVolumeClaim Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PersistentVolumeClaim namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_persistent_volume_claim_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_persistent_volume_claim_status: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PersistentVolumeClaim namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional] Return type V1PersistentVolumeClaim Authorization BearerToken HTTP request headers Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] patch_namespaced_pod V1Pod patch_namespaced_pod(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update the specified Pod Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Pod namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_pod(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_pod: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Pod namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional] Return type V1Pod Authorization BearerToken HTTP request headers Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] patch_namespaced_pod_status V1Pod patch_namespaced_pod_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update status of the specified Pod Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Pod namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_pod_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_pod_status: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Pod namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional] Return type V1Pod Authorization BearerToken HTTP request headers Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] patch_namespaced_pod_template V1PodTemplate patch_namespaced_pod_template(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update the specified PodTemplate Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodTemplate namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_pod_template(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_pod_template: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PodTemplate namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional] Return type V1PodTemplate Authorization BearerToken HTTP request headers Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] patch_namespaced_replication_controller V1ReplicationController patch_namespaced_replication_controller(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update the specified ReplicationController Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ReplicationController namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_replication_controller(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_replication_controller: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ReplicationController namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional] Return type V1ReplicationController Authorization BearerToken HTTP request headers Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] patch_namespaced_replication_controller_scale V1Scale patch_namespaced_replication_controller_scale(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update scale of the specified ReplicationController Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Scale namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_replication_controller_scale(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_replication_controller_scale: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Scale namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional] Return type V1Scale Authorization BearerToken HTTP request headers Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] patch_namespaced_replication_controller_status V1ReplicationController patch_namespaced_replication_controller_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update status of the specified ReplicationController Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ReplicationController namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_replication_controller_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_replication_controller_status: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ReplicationController namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional] Return type V1ReplicationController Authorization BearerToken HTTP request headers Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] patch_namespaced_resource_quota V1ResourceQuota patch_namespaced_resource_quota(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update the specified ResourceQuota Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ResourceQuota namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_resource_quota(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_resource_quota: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ResourceQuota namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional] Return type V1ResourceQuota Authorization BearerToken HTTP request headers Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] patch_namespaced_resource_quota_status V1ResourceQuota patch_namespaced_resource_quota_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update status of the specified ResourceQuota Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ResourceQuota namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_resource_quota_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_resource_quota_status: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ResourceQuota namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional] Return type V1ResourceQuota Authorization BearerToken HTTP request headers Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] patch_namespaced_secret V1Secret patch_namespaced_secret(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update the specified Secret Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Secret namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_secret(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_secret: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Secret namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional] Return type V1Secret Authorization BearerToken HTTP request headers Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] patch_namespaced_service V1Service patch_namespaced_service(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update the specified Service Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Service namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_service(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_service: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Service namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional] Return type V1Service Authorization BearerToken HTTP request headers Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] patch_namespaced_service_account V1ServiceAccount patch_namespaced_service_account(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update the specified ServiceAccount Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceAccount namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_service_account(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_service_account: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ServiceAccount namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional] Return type V1ServiceAccount Authorization BearerToken HTTP request headers Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] patch_namespaced_service_status V1Service patch_namespaced_service_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update status of the specified Service Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Service namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_service_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_service_status: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Service namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional] Return type V1Service Authorization BearerToken HTTP request headers Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] patch_node V1Node patch_node(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update the specified Node Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Node body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_node(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_node: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Node body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional] Return type V1Node Authorization BearerToken HTTP request headers Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] patch_node_status V1Node patch_node_status(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update status of the specified Node Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Node body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_node_status(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_node_status: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Node body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional] Return type V1Node Authorization BearerToken HTTP request headers Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] patch_persistent_volume V1PersistentVolume patch_persistent_volume(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update the specified PersistentVolume Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PersistentVolume body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_persistent_volume(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_persistent_volume: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PersistentVolume body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional] Return type V1PersistentVolume Authorization BearerToken HTTP request headers Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] patch_persistent_volume_status V1PersistentVolume patch_persistent_volume_status(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update status of the specified PersistentVolume Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PersistentVolume body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_persistent_volume_status(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_persistent_volume_status: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PersistentVolume body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional] Return type V1PersistentVolume Authorization BearerToken HTTP request headers Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] read_component_status V1ComponentStatus read_component_status(name, pretty=pretty) read the specified ComponentStatus Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ComponentStatus pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) try: api_response = api_instance.read_component_status(name, pretty=pretty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_component_status: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ComponentStatus pretty str If 'true', then the output is pretty printed. [optional] Return type V1ComponentStatus Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] read_namespace V1Namespace read_namespace(name, pretty=pretty, exact=exact, export=export) read the specified Namespace Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Namespace pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) exact = True # bool | Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. (optional) export = True # bool | Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional) try: api_response = api_instance.read_namespace(name, pretty=pretty, exact=exact, export=export) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespace: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Namespace pretty str If 'true', then the output is pretty printed. [optional] exact bool Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. [optional] export bool Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. [optional] Return type V1Namespace Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] read_namespace_status V1Namespace read_namespace_status(name, pretty=pretty) read status of the specified Namespace Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Namespace pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) try: api_response = api_instance.read_namespace_status(name, pretty=pretty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespace_status: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Namespace pretty str If 'true', then the output is pretty printed. [optional] Return type V1Namespace Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] read_namespaced_config_map V1ConfigMap read_namespaced_config_map(name, namespace, pretty=pretty, exact=exact, export=export) read the specified ConfigMap Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ConfigMap namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) exact = True # bool | Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. (optional) export = True # bool | Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional) try: api_response = api_instance.read_namespaced_config_map(name, namespace, pretty=pretty, exact=exact, export=export) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_config_map: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ConfigMap namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] exact bool Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. [optional] export bool Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. [optional] Return type V1ConfigMap Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] read_namespaced_endpoints V1Endpoints read_namespaced_endpoints(name, namespace, pretty=pretty, exact=exact, export=export) read the specified Endpoints Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Endpoints namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) exact = True # bool | Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. (optional) export = True # bool | Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional) try: api_response = api_instance.read_namespaced_endpoints(name, namespace, pretty=pretty, exact=exact, export=export) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_endpoints: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Endpoints namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] exact bool Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. [optional] export bool Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. [optional] Return type V1Endpoints Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] read_namespaced_event V1Event read_namespaced_event(name, namespace, pretty=pretty, exact=exact, export=export) read the specified Event Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Event namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) exact = True # bool | Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. (optional) export = True # bool | Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional) try: api_response = api_instance.read_namespaced_event(name, namespace, pretty=pretty, exact=exact, export=export) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_event: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Event namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] exact bool Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. [optional] export bool Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. [optional] Return type V1Event Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] read_namespaced_limit_range V1LimitRange read_namespaced_limit_range(name, namespace, pretty=pretty, exact=exact, export=export) read the specified LimitRange Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the LimitRange namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) exact = True # bool | Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. (optional) export = True # bool | Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional) try: api_response = api_instance.read_namespaced_limit_range(name, namespace, pretty=pretty, exact=exact, export=export) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_limit_range: %s\\n\" % e) Parameters Name Type Description Notes name str name of the LimitRange namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] exact bool Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. [optional] export bool Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. [optional] Return type V1LimitRange Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] read_namespaced_persistent_volume_claim V1PersistentVolumeClaim read_namespaced_persistent_volume_claim(name, namespace, pretty=pretty, exact=exact, export=export) read the specified PersistentVolumeClaim Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PersistentVolumeClaim namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) exact = True # bool | Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. (optional) export = True # bool | Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional) try: api_response = api_instance.read_namespaced_persistent_volume_claim(name, namespace, pretty=pretty, exact=exact, export=export) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_persistent_volume_claim: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PersistentVolumeClaim namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] exact bool Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. [optional] export bool Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. [optional] Return type V1PersistentVolumeClaim Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] read_namespaced_persistent_volume_claim_status V1PersistentVolumeClaim read_namespaced_persistent_volume_claim_status(name, namespace, pretty=pretty) read status of the specified PersistentVolumeClaim Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PersistentVolumeClaim namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) try: api_response = api_instance.read_namespaced_persistent_volume_claim_status(name, namespace, pretty=pretty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_persistent_volume_claim_status: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PersistentVolumeClaim namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] Return type V1PersistentVolumeClaim Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] read_namespaced_pod V1Pod read_namespaced_pod(name, namespace, pretty=pretty, exact=exact, export=export) read the specified Pod Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Pod namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) exact = True # bool | Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. (optional) export = True # bool | Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional) try: api_response = api_instance.read_namespaced_pod(name, namespace, pretty=pretty, exact=exact, export=export) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_pod: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Pod namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] exact bool Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. [optional] export bool Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. [optional] Return type V1Pod Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] read_namespaced_pod_log str read_namespaced_pod_log(name, namespace, container=container, follow=follow, insecure_skip_tls_verify_backend=insecure_skip_tls_verify_backend, limit_bytes=limit_bytes, pretty=pretty, previous=previous, since_seconds=since_seconds, tail_lines=tail_lines, timestamps=timestamps) read log of the specified Pod Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Pod namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects container = 'container_example' # str | The container for which to stream logs. Defaults to only container if there is one container in the pod. (optional) follow = True # bool | Follow the log stream of the pod. Defaults to false. (optional) insecure_skip_tls_verify_backend = True # bool | insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the serving certificate of the backend it is connecting to. This will make the HTTPS connection between the apiserver and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real kubelet. If the kubelet is configured to verify the apiserver's TLS credentials, it does not mean the connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept the actual log data coming from the real kubelet). (optional) limit_bytes = 56 # int | If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) previous = True # bool | Return previous terminated container logs. Defaults to false. (optional) since_seconds = 56 # int | A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified. (optional) tail_lines = 56 # int | If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime (optional) timestamps = True # bool | If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false. (optional) try: api_response = api_instance.read_namespaced_pod_log(name, namespace, container=container, follow=follow, insecure_skip_tls_verify_backend=insecure_skip_tls_verify_backend, limit_bytes=limit_bytes, pretty=pretty, previous=previous, since_seconds=since_seconds, tail_lines=tail_lines, timestamps=timestamps) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_pod_log: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Pod namespace str object name and auth scope, such as for teams and projects container str The container for which to stream logs. Defaults to only container if there is one container in the pod. [optional] follow bool Follow the log stream of the pod. Defaults to false. [optional] insecure_skip_tls_verify_backend bool insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the serving certificate of the backend it is connecting to. This will make the HTTPS connection between the apiserver and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real kubelet. If the kubelet is configured to verify the apiserver's TLS credentials, it does not mean the connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept the actual log data coming from the real kubelet). [optional] limit_bytes int If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit. [optional] pretty str If 'true', then the output is pretty printed. [optional] previous bool Return previous terminated container logs. Defaults to false. [optional] since_seconds int A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified. [optional] tail_lines int If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime [optional] timestamps bool If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false. [optional] Return type str Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : text/plain, application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] read_namespaced_pod_status V1Pod read_namespaced_pod_status(name, namespace, pretty=pretty) read status of the specified Pod Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Pod namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) try: api_response = api_instance.read_namespaced_pod_status(name, namespace, pretty=pretty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_pod_status: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Pod namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] Return type V1Pod Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] read_namespaced_pod_template V1PodTemplate read_namespaced_pod_template(name, namespace, pretty=pretty, exact=exact, export=export) read the specified PodTemplate Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodTemplate namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) exact = True # bool | Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. (optional) export = True # bool | Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional) try: api_response = api_instance.read_namespaced_pod_template(name, namespace, pretty=pretty, exact=exact, export=export) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_pod_template: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PodTemplate namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] exact bool Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. [optional] export bool Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. [optional] Return type V1PodTemplate Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] read_namespaced_replication_controller V1ReplicationController read_namespaced_replication_controller(name, namespace, pretty=pretty, exact=exact, export=export) read the specified ReplicationController Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ReplicationController namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) exact = True # bool | Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. (optional) export = True # bool | Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional) try: api_response = api_instance.read_namespaced_replication_controller(name, namespace, pretty=pretty, exact=exact, export=export) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_replication_controller: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ReplicationController namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] exact bool Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. [optional] export bool Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. [optional] Return type V1ReplicationController Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] read_namespaced_replication_controller_scale V1Scale read_namespaced_replication_controller_scale(name, namespace, pretty=pretty) read scale of the specified ReplicationController Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Scale namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) try: api_response = api_instance.read_namespaced_replication_controller_scale(name, namespace, pretty=pretty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_replication_controller_scale: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Scale namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] Return type V1Scale Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] read_namespaced_replication_controller_status V1ReplicationController read_namespaced_replication_controller_status(name, namespace, pretty=pretty) read status of the specified ReplicationController Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ReplicationController namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) try: api_response = api_instance.read_namespaced_replication_controller_status(name, namespace, pretty=pretty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_replication_controller_status: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ReplicationController namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] Return type V1ReplicationController Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] read_namespaced_resource_quota V1ResourceQuota read_namespaced_resource_quota(name, namespace, pretty=pretty, exact=exact, export=export) read the specified ResourceQuota Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ResourceQuota namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) exact = True # bool | Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. (optional) export = True # bool | Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional) try: api_response = api_instance.read_namespaced_resource_quota(name, namespace, pretty=pretty, exact=exact, export=export) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_resource_quota: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ResourceQuota namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] exact bool Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. [optional] export bool Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. [optional] Return type V1ResourceQuota Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] read_namespaced_resource_quota_status V1ResourceQuota read_namespaced_resource_quota_status(name, namespace, pretty=pretty) read status of the specified ResourceQuota Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ResourceQuota namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) try: api_response = api_instance.read_namespaced_resource_quota_status(name, namespace, pretty=pretty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_resource_quota_status: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ResourceQuota namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] Return type V1ResourceQuota Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] read_namespaced_secret V1Secret read_namespaced_secret(name, namespace, pretty=pretty, exact=exact, export=export) read the specified Secret Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Secret namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) exact = True # bool | Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. (optional) export = True # bool | Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional) try: api_response = api_instance.read_namespaced_secret(name, namespace, pretty=pretty, exact=exact, export=export) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_secret: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Secret namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] exact bool Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. [optional] export bool Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. [optional] Return type V1Secret Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] read_namespaced_service V1Service read_namespaced_service(name, namespace, pretty=pretty, exact=exact, export=export) read the specified Service Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Service namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) exact = True # bool | Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. (optional) export = True # bool | Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional) try: api_response = api_instance.read_namespaced_service(name, namespace, pretty=pretty, exact=exact, export=export) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_service: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Service namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] exact bool Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. [optional] export bool Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. [optional] Return type V1Service Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] read_namespaced_service_account V1ServiceAccount read_namespaced_service_account(name, namespace, pretty=pretty, exact=exact, export=export) read the specified ServiceAccount Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceAccount namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) exact = True # bool | Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. (optional) export = True # bool | Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional) try: api_response = api_instance.read_namespaced_service_account(name, namespace, pretty=pretty, exact=exact, export=export) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_service_account: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ServiceAccount namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] exact bool Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. [optional] export bool Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. [optional] Return type V1ServiceAccount Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] read_namespaced_service_status V1Service read_namespaced_service_status(name, namespace, pretty=pretty) read status of the specified Service Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Service namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) try: api_response = api_instance.read_namespaced_service_status(name, namespace, pretty=pretty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_service_status: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Service namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] Return type V1Service Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] read_node V1Node read_node(name, pretty=pretty, exact=exact, export=export) read the specified Node Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Node pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) exact = True # bool | Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. (optional) export = True # bool | Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional) try: api_response = api_instance.read_node(name, pretty=pretty, exact=exact, export=export) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_node: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Node pretty str If 'true', then the output is pretty printed. [optional] exact bool Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. [optional] export bool Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. [optional] Return type V1Node Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] read_node_status V1Node read_node_status(name, pretty=pretty) read status of the specified Node Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Node pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) try: api_response = api_instance.read_node_status(name, pretty=pretty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_node_status: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Node pretty str If 'true', then the output is pretty printed. [optional] Return type V1Node Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] read_persistent_volume V1PersistentVolume read_persistent_volume(name, pretty=pretty, exact=exact, export=export) read the specified PersistentVolume Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PersistentVolume pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) exact = True # bool | Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. (optional) export = True # bool | Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional) try: api_response = api_instance.read_persistent_volume(name, pretty=pretty, exact=exact, export=export) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_persistent_volume: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PersistentVolume pretty str If 'true', then the output is pretty printed. [optional] exact bool Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. [optional] export bool Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. [optional] Return type V1PersistentVolume Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] read_persistent_volume_status V1PersistentVolume read_persistent_volume_status(name, pretty=pretty) read status of the specified PersistentVolume Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PersistentVolume pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) try: api_response = api_instance.read_persistent_volume_status(name, pretty=pretty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_persistent_volume_status: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PersistentVolume pretty str If 'true', then the output is pretty printed. [optional] Return type V1PersistentVolume Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] replace_namespace V1Namespace replace_namespace(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace the specified Namespace Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Namespace body = kubernetes.client.V1Namespace() # V1Namespace | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespace(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespace: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Namespace body V1Namespace pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1Namespace Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] replace_namespace_finalize V1Namespace replace_namespace_finalize(name, body, dry_run=dry_run, field_manager=field_manager, pretty=pretty) replace finalize of the specified Namespace Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Namespace body = kubernetes.client.V1Namespace() # V1Namespace | dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) try: api_response = api_instance.replace_namespace_finalize(name, body, dry_run=dry_run, field_manager=field_manager, pretty=pretty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespace_finalize: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Namespace body V1Namespace dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] pretty str If 'true', then the output is pretty printed. [optional] Return type V1Namespace Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] replace_namespace_status V1Namespace replace_namespace_status(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace status of the specified Namespace Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Namespace body = kubernetes.client.V1Namespace() # V1Namespace | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespace_status(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespace_status: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Namespace body V1Namespace pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1Namespace Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] replace_namespaced_config_map V1ConfigMap replace_namespaced_config_map(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace the specified ConfigMap Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ConfigMap namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1ConfigMap() # V1ConfigMap | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_config_map(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_config_map: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ConfigMap namespace str object name and auth scope, such as for teams and projects body V1ConfigMap pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1ConfigMap Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] replace_namespaced_endpoints V1Endpoints replace_namespaced_endpoints(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace the specified Endpoints Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Endpoints namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1Endpoints() # V1Endpoints | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_endpoints(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_endpoints: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Endpoints namespace str object name and auth scope, such as for teams and projects body V1Endpoints pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1Endpoints Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] replace_namespaced_event V1Event replace_namespaced_event(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace the specified Event Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Event namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1Event() # V1Event | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_event(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_event: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Event namespace str object name and auth scope, such as for teams and projects body V1Event pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1Event Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] replace_namespaced_limit_range V1LimitRange replace_namespaced_limit_range(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace the specified LimitRange Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the LimitRange namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1LimitRange() # V1LimitRange | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_limit_range(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_limit_range: %s\\n\" % e) Parameters Name Type Description Notes name str name of the LimitRange namespace str object name and auth scope, such as for teams and projects body V1LimitRange pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1LimitRange Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] replace_namespaced_persistent_volume_claim V1PersistentVolumeClaim replace_namespaced_persistent_volume_claim(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace the specified PersistentVolumeClaim Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PersistentVolumeClaim namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1PersistentVolumeClaim() # V1PersistentVolumeClaim | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_persistent_volume_claim(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_persistent_volume_claim: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PersistentVolumeClaim namespace str object name and auth scope, such as for teams and projects body V1PersistentVolumeClaim pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1PersistentVolumeClaim Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] replace_namespaced_persistent_volume_claim_status V1PersistentVolumeClaim replace_namespaced_persistent_volume_claim_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace status of the specified PersistentVolumeClaim Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PersistentVolumeClaim namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1PersistentVolumeClaim() # V1PersistentVolumeClaim | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_persistent_volume_claim_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_persistent_volume_claim_status: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PersistentVolumeClaim namespace str object name and auth scope, such as for teams and projects body V1PersistentVolumeClaim pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1PersistentVolumeClaim Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] replace_namespaced_pod V1Pod replace_namespaced_pod(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace the specified Pod Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Pod namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1Pod() # V1Pod | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_pod(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_pod: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Pod namespace str object name and auth scope, such as for teams and projects body V1Pod pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1Pod Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] replace_namespaced_pod_status V1Pod replace_namespaced_pod_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace status of the specified Pod Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Pod namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1Pod() # V1Pod | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_pod_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_pod_status: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Pod namespace str object name and auth scope, such as for teams and projects body V1Pod pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1Pod Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] replace_namespaced_pod_template V1PodTemplate replace_namespaced_pod_template(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace the specified PodTemplate Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodTemplate namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1PodTemplate() # V1PodTemplate | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_pod_template(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_pod_template: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PodTemplate namespace str object name and auth scope, such as for teams and projects body V1PodTemplate pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1PodTemplate Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] replace_namespaced_replication_controller V1ReplicationController replace_namespaced_replication_controller(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace the specified ReplicationController Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ReplicationController namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1ReplicationController() # V1ReplicationController | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_replication_controller(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_replication_controller: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ReplicationController namespace str object name and auth scope, such as for teams and projects body V1ReplicationController pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1ReplicationController Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] replace_namespaced_replication_controller_scale V1Scale replace_namespaced_replication_controller_scale(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace scale of the specified ReplicationController Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Scale namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1Scale() # V1Scale | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_replication_controller_scale(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_replication_controller_scale: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Scale namespace str object name and auth scope, such as for teams and projects body V1Scale pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1Scale Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] replace_namespaced_replication_controller_status V1ReplicationController replace_namespaced_replication_controller_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace status of the specified ReplicationController Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ReplicationController namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1ReplicationController() # V1ReplicationController | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_replication_controller_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_replication_controller_status: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ReplicationController namespace str object name and auth scope, such as for teams and projects body V1ReplicationController pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1ReplicationController Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] replace_namespaced_resource_quota V1ResourceQuota replace_namespaced_resource_quota(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace the specified ResourceQuota Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ResourceQuota namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1ResourceQuota() # V1ResourceQuota | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_resource_quota(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_resource_quota: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ResourceQuota namespace str object name and auth scope, such as for teams and projects body V1ResourceQuota pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1ResourceQuota Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] replace_namespaced_resource_quota_status V1ResourceQuota replace_namespaced_resource_quota_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace status of the specified ResourceQuota Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ResourceQuota namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1ResourceQuota() # V1ResourceQuota | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_resource_quota_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_resource_quota_status: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ResourceQuota namespace str object name and auth scope, such as for teams and projects body V1ResourceQuota pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1ResourceQuota Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] replace_namespaced_secret V1Secret replace_namespaced_secret(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace the specified Secret Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Secret namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1Secret() # V1Secret | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_secret(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_secret: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Secret namespace str object name and auth scope, such as for teams and projects body V1Secret pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1Secret Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] replace_namespaced_service V1Service replace_namespaced_service(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace the specified Service Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Service namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1Service() # V1Service | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_service(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_service: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Service namespace str object name and auth scope, such as for teams and projects body V1Service pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1Service Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] replace_namespaced_service_account V1ServiceAccount replace_namespaced_service_account(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace the specified ServiceAccount Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceAccount namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1ServiceAccount() # V1ServiceAccount | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_service_account(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_service_account: %s\\n\" % e) Parameters Name Type Description Notes name str name of the ServiceAccount namespace str object name and auth scope, such as for teams and projects body V1ServiceAccount pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1ServiceAccount Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] replace_namespaced_service_status V1Service replace_namespaced_service_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace status of the specified Service Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Service namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1Service() # V1Service | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_service_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_service_status: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Service namespace str object name and auth scope, such as for teams and projects body V1Service pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1Service Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] replace_node V1Node replace_node(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace the specified Node Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Node body = kubernetes.client.V1Node() # V1Node | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_node(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_node: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Node body V1Node pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1Node Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] replace_node_status V1Node replace_node_status(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace status of the specified Node Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Node body = kubernetes.client.V1Node() # V1Node | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_node_status(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_node_status: %s\\n\" % e) Parameters Name Type Description Notes name str name of the Node body V1Node pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1Node Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] replace_persistent_volume V1PersistentVolume replace_persistent_volume(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace the specified PersistentVolume Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PersistentVolume body = kubernetes.client.V1PersistentVolume() # V1PersistentVolume | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_persistent_volume(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_persistent_volume: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PersistentVolume body V1PersistentVolume pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1PersistentVolume Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README] replace_persistent_volume_status V1PersistentVolume replace_persistent_volume_status(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace status of the specified PersistentVolume Example Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PersistentVolume body = kubernetes.client.V1PersistentVolume() # V1PersistentVolume | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_persistent_volume_status(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_persistent_volume_status: %s\\n\" % e) Parameters Name Type Description Notes name str name of the PersistentVolume body V1PersistentVolume pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] Return type V1PersistentVolume Authorization BearerToken HTTP request headers Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf HTTP response details Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"kubernetes.client.CoreV1Api"},{"location":"#kubernetesclientcorev1api","text":"All URIs are relative to http://localhost Method HTTP request Description connect_delete_namespaced_pod_proxy DELETE /api/v1/namespaces/{namespace}/pods/{name}/proxy connect_delete_namespaced_pod_proxy_with_path DELETE /api/v1/namespaces/{namespace}/pods/{name}/proxy/{path} connect_delete_namespaced_service_proxy DELETE /api/v1/namespaces/{namespace}/services/{name}/proxy connect_delete_namespaced_service_proxy_with_path DELETE /api/v1/namespaces/{namespace}/services/{name}/proxy/{path} connect_delete_node_proxy DELETE /api/v1/nodes/{name}/proxy connect_delete_node_proxy_with_path DELETE /api/v1/nodes/{name}/proxy/{path} connect_get_namespaced_pod_attach GET /api/v1/namespaces/{namespace}/pods/{name}/attach connect_get_namespaced_pod_exec GET /api/v1/namespaces/{namespace}/pods/{name}/exec connect_get_namespaced_pod_portforward GET /api/v1/namespaces/{namespace}/pods/{name}/portforward connect_get_namespaced_pod_proxy GET /api/v1/namespaces/{namespace}/pods/{name}/proxy connect_get_namespaced_pod_proxy_with_path GET /api/v1/namespaces/{namespace}/pods/{name}/proxy/{path} connect_get_namespaced_service_proxy GET /api/v1/namespaces/{namespace}/services/{name}/proxy connect_get_namespaced_service_proxy_with_path GET /api/v1/namespaces/{namespace}/services/{name}/proxy/{path} connect_get_node_proxy GET /api/v1/nodes/{name}/proxy connect_get_node_proxy_with_path GET /api/v1/nodes/{name}/proxy/{path} connect_head_namespaced_pod_proxy HEAD /api/v1/namespaces/{namespace}/pods/{name}/proxy connect_head_namespaced_pod_proxy_with_path HEAD /api/v1/namespaces/{namespace}/pods/{name}/proxy/{path} connect_head_namespaced_service_proxy HEAD /api/v1/namespaces/{namespace}/services/{name}/proxy connect_head_namespaced_service_proxy_with_path HEAD /api/v1/namespaces/{namespace}/services/{name}/proxy/{path} connect_head_node_proxy HEAD /api/v1/nodes/{name}/proxy connect_head_node_proxy_with_path HEAD /api/v1/nodes/{name}/proxy/{path} connect_options_namespaced_pod_proxy OPTIONS /api/v1/namespaces/{namespace}/pods/{name}/proxy connect_options_namespaced_pod_proxy_with_path OPTIONS /api/v1/namespaces/{namespace}/pods/{name}/proxy/{path} connect_options_namespaced_service_proxy OPTIONS /api/v1/namespaces/{namespace}/services/{name}/proxy connect_options_namespaced_service_proxy_with_path OPTIONS /api/v1/namespaces/{namespace}/services/{name}/proxy/{path} connect_options_node_proxy OPTIONS /api/v1/nodes/{name}/proxy connect_options_node_proxy_with_path OPTIONS /api/v1/nodes/{name}/proxy/{path} connect_patch_namespaced_pod_proxy PATCH /api/v1/namespaces/{namespace}/pods/{name}/proxy connect_patch_namespaced_pod_proxy_with_path PATCH /api/v1/namespaces/{namespace}/pods/{name}/proxy/{path} connect_patch_namespaced_service_proxy PATCH /api/v1/namespaces/{namespace}/services/{name}/proxy connect_patch_namespaced_service_proxy_with_path PATCH /api/v1/namespaces/{namespace}/services/{name}/proxy/{path} connect_patch_node_proxy PATCH /api/v1/nodes/{name}/proxy connect_patch_node_proxy_with_path PATCH /api/v1/nodes/{name}/proxy/{path} connect_post_namespaced_pod_attach POST /api/v1/namespaces/{namespace}/pods/{name}/attach connect_post_namespaced_pod_exec POST /api/v1/namespaces/{namespace}/pods/{name}/exec connect_post_namespaced_pod_portforward POST /api/v1/namespaces/{namespace}/pods/{name}/portforward connect_post_namespaced_pod_proxy POST /api/v1/namespaces/{namespace}/pods/{name}/proxy connect_post_namespaced_pod_proxy_with_path POST /api/v1/namespaces/{namespace}/pods/{name}/proxy/{path} connect_post_namespaced_service_proxy POST /api/v1/namespaces/{namespace}/services/{name}/proxy connect_post_namespaced_service_proxy_with_path POST /api/v1/namespaces/{namespace}/services/{name}/proxy/{path} connect_post_node_proxy POST /api/v1/nodes/{name}/proxy connect_post_node_proxy_with_path POST /api/v1/nodes/{name}/proxy/{path} connect_put_namespaced_pod_proxy PUT /api/v1/namespaces/{namespace}/pods/{name}/proxy connect_put_namespaced_pod_proxy_with_path PUT /api/v1/namespaces/{namespace}/pods/{name}/proxy/{path} connect_put_namespaced_service_proxy PUT /api/v1/namespaces/{namespace}/services/{name}/proxy connect_put_namespaced_service_proxy_with_path PUT /api/v1/namespaces/{namespace}/services/{name}/proxy/{path} connect_put_node_proxy PUT /api/v1/nodes/{name}/proxy connect_put_node_proxy_with_path PUT /api/v1/nodes/{name}/proxy/{path} create_namespace POST /api/v1/namespaces create_namespaced_binding POST /api/v1/namespaces/{namespace}/bindings create_namespaced_config_map POST /api/v1/namespaces/{namespace}/configmaps create_namespaced_endpoints POST /api/v1/namespaces/{namespace}/endpoints create_namespaced_event POST /api/v1/namespaces/{namespace}/events create_namespaced_limit_range POST /api/v1/namespaces/{namespace}/limitranges create_namespaced_persistent_volume_claim POST /api/v1/namespaces/{namespace}/persistentvolumeclaims create_namespaced_pod POST /api/v1/namespaces/{namespace}/pods create_namespaced_pod_binding POST /api/v1/namespaces/{namespace}/pods/{name}/binding create_namespaced_pod_eviction POST /api/v1/namespaces/{namespace}/pods/{name}/eviction create_namespaced_pod_template POST /api/v1/namespaces/{namespace}/podtemplates create_namespaced_replication_controller POST /api/v1/namespaces/{namespace}/replicationcontrollers create_namespaced_resource_quota POST /api/v1/namespaces/{namespace}/resourcequotas create_namespaced_secret POST /api/v1/namespaces/{namespace}/secrets create_namespaced_service POST /api/v1/namespaces/{namespace}/services create_namespaced_service_account POST /api/v1/namespaces/{namespace}/serviceaccounts create_namespaced_service_account_token POST /api/v1/namespaces/{namespace}/serviceaccounts/{name}/token create_node POST /api/v1/nodes create_persistent_volume POST /api/v1/persistentvolumes delete_collection_namespaced_config_map DELETE /api/v1/namespaces/{namespace}/configmaps delete_collection_namespaced_endpoints DELETE /api/v1/namespaces/{namespace}/endpoints delete_collection_namespaced_event DELETE /api/v1/namespaces/{namespace}/events delete_collection_namespaced_limit_range DELETE /api/v1/namespaces/{namespace}/limitranges delete_collection_namespaced_persistent_volume_claim DELETE /api/v1/namespaces/{namespace}/persistentvolumeclaims delete_collection_namespaced_pod DELETE /api/v1/namespaces/{namespace}/pods delete_collection_namespaced_pod_template DELETE /api/v1/namespaces/{namespace}/podtemplates delete_collection_namespaced_replication_controller DELETE /api/v1/namespaces/{namespace}/replicationcontrollers delete_collection_namespaced_resource_quota DELETE /api/v1/namespaces/{namespace}/resourcequotas delete_collection_namespaced_secret DELETE /api/v1/namespaces/{namespace}/secrets delete_collection_namespaced_service_account DELETE /api/v1/namespaces/{namespace}/serviceaccounts delete_collection_node DELETE /api/v1/nodes delete_collection_persistent_volume DELETE /api/v1/persistentvolumes delete_namespace DELETE /api/v1/namespaces/{name} delete_namespaced_config_map DELETE /api/v1/namespaces/{namespace}/configmaps/{name} delete_namespaced_endpoints DELETE /api/v1/namespaces/{namespace}/endpoints/{name} delete_namespaced_event DELETE /api/v1/namespaces/{namespace}/events/{name} delete_namespaced_limit_range DELETE /api/v1/namespaces/{namespace}/limitranges/{name} delete_namespaced_persistent_volume_claim DELETE /api/v1/namespaces/{namespace}/persistentvolumeclaims/{name} delete_namespaced_pod DELETE /api/v1/namespaces/{namespace}/pods/{name} delete_namespaced_pod_template DELETE /api/v1/namespaces/{namespace}/podtemplates/{name} delete_namespaced_replication_controller DELETE /api/v1/namespaces/{namespace}/replicationcontrollers/{name} delete_namespaced_resource_quota DELETE /api/v1/namespaces/{namespace}/resourcequotas/{name} delete_namespaced_secret DELETE /api/v1/namespaces/{namespace}/secrets/{name} delete_namespaced_service DELETE /api/v1/namespaces/{namespace}/services/{name} delete_namespaced_service_account DELETE /api/v1/namespaces/{namespace}/serviceaccounts/{name} delete_node DELETE /api/v1/nodes/{name} delete_persistent_volume DELETE /api/v1/persistentvolumes/{name} get_api_resources GET /api/v1/ list_component_status GET /api/v1/componentstatuses list_config_map_for_all_namespaces GET /api/v1/configmaps list_endpoints_for_all_namespaces GET /api/v1/endpoints list_event_for_all_namespaces GET /api/v1/events list_limit_range_for_all_namespaces GET /api/v1/limitranges list_namespace GET /api/v1/namespaces list_namespaced_config_map GET /api/v1/namespaces/{namespace}/configmaps list_namespaced_endpoints GET /api/v1/namespaces/{namespace}/endpoints list_namespaced_event GET /api/v1/namespaces/{namespace}/events list_namespaced_limit_range GET /api/v1/namespaces/{namespace}/limitranges list_namespaced_persistent_volume_claim GET /api/v1/namespaces/{namespace}/persistentvolumeclaims list_namespaced_pod GET /api/v1/namespaces/{namespace}/pods list_namespaced_pod_template GET /api/v1/namespaces/{namespace}/podtemplates list_namespaced_replication_controller GET /api/v1/namespaces/{namespace}/replicationcontrollers list_namespaced_resource_quota GET /api/v1/namespaces/{namespace}/resourcequotas list_namespaced_secret GET /api/v1/namespaces/{namespace}/secrets list_namespaced_service GET /api/v1/namespaces/{namespace}/services list_namespaced_service_account GET /api/v1/namespaces/{namespace}/serviceaccounts list_node GET /api/v1/nodes list_persistent_volume GET /api/v1/persistentvolumes list_persistent_volume_claim_for_all_namespaces GET /api/v1/persistentvolumeclaims list_pod_for_all_namespaces GET /api/v1/pods list_pod_template_for_all_namespaces GET /api/v1/podtemplates list_replication_controller_for_all_namespaces GET /api/v1/replicationcontrollers list_resource_quota_for_all_namespaces GET /api/v1/resourcequotas list_secret_for_all_namespaces GET /api/v1/secrets list_service_account_for_all_namespaces GET /api/v1/serviceaccounts list_service_for_all_namespaces GET /api/v1/services patch_namespace PATCH /api/v1/namespaces/{name} patch_namespace_status PATCH /api/v1/namespaces/{name}/status patch_namespaced_config_map PATCH /api/v1/namespaces/{namespace}/configmaps/{name} patch_namespaced_endpoints PATCH /api/v1/namespaces/{namespace}/endpoints/{name} patch_namespaced_event PATCH /api/v1/namespaces/{namespace}/events/{name} patch_namespaced_limit_range PATCH /api/v1/namespaces/{namespace}/limitranges/{name} patch_namespaced_persistent_volume_claim PATCH /api/v1/namespaces/{namespace}/persistentvolumeclaims/{name} patch_namespaced_persistent_volume_claim_status PATCH /api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status patch_namespaced_pod PATCH /api/v1/namespaces/{namespace}/pods/{name} patch_namespaced_pod_status PATCH /api/v1/namespaces/{namespace}/pods/{name}/status patch_namespaced_pod_template PATCH /api/v1/namespaces/{namespace}/podtemplates/{name} patch_namespaced_replication_controller PATCH /api/v1/namespaces/{namespace}/replicationcontrollers/{name} patch_namespaced_replication_controller_scale PATCH /api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale patch_namespaced_replication_controller_status PATCH /api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status patch_namespaced_resource_quota PATCH /api/v1/namespaces/{namespace}/resourcequotas/{name} patch_namespaced_resource_quota_status PATCH /api/v1/namespaces/{namespace}/resourcequotas/{name}/status patch_namespaced_secret PATCH /api/v1/namespaces/{namespace}/secrets/{name} patch_namespaced_service PATCH /api/v1/namespaces/{namespace}/services/{name} patch_namespaced_service_account PATCH /api/v1/namespaces/{namespace}/serviceaccounts/{name} patch_namespaced_service_status PATCH /api/v1/namespaces/{namespace}/services/{name}/status patch_node PATCH /api/v1/nodes/{name} patch_node_status PATCH /api/v1/nodes/{name}/status patch_persistent_volume PATCH /api/v1/persistentvolumes/{name} patch_persistent_volume_status PATCH /api/v1/persistentvolumes/{name}/status read_component_status GET /api/v1/componentstatuses/{name} read_namespace GET /api/v1/namespaces/{name} read_namespace_status GET /api/v1/namespaces/{name}/status read_namespaced_config_map GET /api/v1/namespaces/{namespace}/configmaps/{name} read_namespaced_endpoints GET /api/v1/namespaces/{namespace}/endpoints/{name} read_namespaced_event GET /api/v1/namespaces/{namespace}/events/{name} read_namespaced_limit_range GET /api/v1/namespaces/{namespace}/limitranges/{name} read_namespaced_persistent_volume_claim GET /api/v1/namespaces/{namespace}/persistentvolumeclaims/{name} read_namespaced_persistent_volume_claim_status GET /api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status read_namespaced_pod GET /api/v1/namespaces/{namespace}/pods/{name} read_namespaced_pod_log GET /api/v1/namespaces/{namespace}/pods/{name}/log read_namespaced_pod_status GET /api/v1/namespaces/{namespace}/pods/{name}/status read_namespaced_pod_template GET /api/v1/namespaces/{namespace}/podtemplates/{name} read_namespaced_replication_controller GET /api/v1/namespaces/{namespace}/replicationcontrollers/{name} read_namespaced_replication_controller_scale GET /api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale read_namespaced_replication_controller_status GET /api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status read_namespaced_resource_quota GET /api/v1/namespaces/{namespace}/resourcequotas/{name} read_namespaced_resource_quota_status GET /api/v1/namespaces/{namespace}/resourcequotas/{name}/status read_namespaced_secret GET /api/v1/namespaces/{namespace}/secrets/{name} read_namespaced_service GET /api/v1/namespaces/{namespace}/services/{name} read_namespaced_service_account GET /api/v1/namespaces/{namespace}/serviceaccounts/{name} read_namespaced_service_status GET /api/v1/namespaces/{namespace}/services/{name}/status read_node GET /api/v1/nodes/{name} read_node_status GET /api/v1/nodes/{name}/status read_persistent_volume GET /api/v1/persistentvolumes/{name} read_persistent_volume_status GET /api/v1/persistentvolumes/{name}/status replace_namespace PUT /api/v1/namespaces/{name} replace_namespace_finalize PUT /api/v1/namespaces/{name}/finalize replace_namespace_status PUT /api/v1/namespaces/{name}/status replace_namespaced_config_map PUT /api/v1/namespaces/{namespace}/configmaps/{name} replace_namespaced_endpoints PUT /api/v1/namespaces/{namespace}/endpoints/{name} replace_namespaced_event PUT /api/v1/namespaces/{namespace}/events/{name} replace_namespaced_limit_range PUT /api/v1/namespaces/{namespace}/limitranges/{name} replace_namespaced_persistent_volume_claim PUT /api/v1/namespaces/{namespace}/persistentvolumeclaims/{name} replace_namespaced_persistent_volume_claim_status PUT /api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status replace_namespaced_pod PUT /api/v1/namespaces/{namespace}/pods/{name} replace_namespaced_pod_status PUT /api/v1/namespaces/{namespace}/pods/{name}/status replace_namespaced_pod_template PUT /api/v1/namespaces/{namespace}/podtemplates/{name} replace_namespaced_replication_controller PUT /api/v1/namespaces/{namespace}/replicationcontrollers/{name} replace_namespaced_replication_controller_scale PUT /api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale replace_namespaced_replication_controller_status PUT /api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status replace_namespaced_resource_quota PUT /api/v1/namespaces/{namespace}/resourcequotas/{name} replace_namespaced_resource_quota_status PUT /api/v1/namespaces/{namespace}/resourcequotas/{name}/status replace_namespaced_secret PUT /api/v1/namespaces/{namespace}/secrets/{name} replace_namespaced_service PUT /api/v1/namespaces/{namespace}/services/{name} replace_namespaced_service_account PUT /api/v1/namespaces/{namespace}/serviceaccounts/{name} replace_namespaced_service_status PUT /api/v1/namespaces/{namespace}/services/{name}/status replace_node PUT /api/v1/nodes/{name} replace_node_status PUT /api/v1/nodes/{name}/status replace_persistent_volume PUT /api/v1/persistentvolumes/{name} replace_persistent_volume_status PUT /api/v1/persistentvolumes/{name}/status","title":"kubernetes.client.CoreV1Api"},{"location":"#connect_delete_namespaced_pod_proxy","text":"str connect_delete_namespaced_pod_proxy(name, namespace, path=path) connect DELETE requests to proxy of Pod","title":"connect_delete_namespaced_pod_proxy"},{"location":"#example","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | Path is the URL path to use for the current proxy request to pod. (optional) try: api_response = api_instance.connect_delete_namespaced_pod_proxy(name, namespace, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_delete_namespaced_pod_proxy: %s\\n\" % e)","title":"Example"},{"location":"#parameters","text":"Name Type Description Notes name str name of the PodProxyOptions namespace str object name and auth scope, such as for teams and projects path str Path is the URL path to use for the current proxy request to pod. [optional]","title":"Parameters"},{"location":"#return-type","text":"str","title":"Return type"},{"location":"#authorization","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_delete_namespaced_pod_proxy_with_path","text":"str connect_delete_namespaced_pod_proxy_with_path(name, namespace, path, path2=path2) connect DELETE requests to proxy of Pod","title":"connect_delete_namespaced_pod_proxy_with_path"},{"location":"#example_1","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the URL path to use for the current proxy request to pod. (optional) try: api_response = api_instance.connect_delete_namespaced_pod_proxy_with_path(name, namespace, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_delete_namespaced_pod_proxy_with_path: %s\\n\" % e)","title":"Example"},{"location":"#parameters_1","text":"Name Type Description Notes name str name of the PodProxyOptions namespace str object name and auth scope, such as for teams and projects path str path to the resource path2 str Path is the URL path to use for the current proxy request to pod. [optional]","title":"Parameters"},{"location":"#return-type_1","text":"str","title":"Return type"},{"location":"#authorization_1","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_1","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_1","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_delete_namespaced_service_proxy","text":"str connect_delete_namespaced_service_proxy(name, namespace, path=path) connect DELETE requests to proxy of Service","title":"connect_delete_namespaced_service_proxy"},{"location":"#example_2","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. (optional) try: api_response = api_instance.connect_delete_namespaced_service_proxy(name, namespace, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_delete_namespaced_service_proxy: %s\\n\" % e)","title":"Example"},{"location":"#parameters_2","text":"Name Type Description Notes name str name of the ServiceProxyOptions namespace str object name and auth scope, such as for teams and projects path str Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. [optional]","title":"Parameters"},{"location":"#return-type_2","text":"str","title":"Return type"},{"location":"#authorization_2","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_2","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_2","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_delete_namespaced_service_proxy_with_path","text":"str connect_delete_namespaced_service_proxy_with_path(name, namespace, path, path2=path2) connect DELETE requests to proxy of Service","title":"connect_delete_namespaced_service_proxy_with_path"},{"location":"#example_3","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. (optional) try: api_response = api_instance.connect_delete_namespaced_service_proxy_with_path(name, namespace, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_delete_namespaced_service_proxy_with_path: %s\\n\" % e)","title":"Example"},{"location":"#parameters_3","text":"Name Type Description Notes name str name of the ServiceProxyOptions namespace str object name and auth scope, such as for teams and projects path str path to the resource path2 str Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. [optional]","title":"Parameters"},{"location":"#return-type_3","text":"str","title":"Return type"},{"location":"#authorization_3","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_3","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_3","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_delete_node_proxy","text":"str connect_delete_node_proxy(name, path=path) connect DELETE requests to proxy of Node","title":"connect_delete_node_proxy"},{"location":"#example_4","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the NodeProxyOptions path = 'path_example' # str | Path is the URL path to use for the current proxy request to node. (optional) try: api_response = api_instance.connect_delete_node_proxy(name, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_delete_node_proxy: %s\\n\" % e)","title":"Example"},{"location":"#parameters_4","text":"Name Type Description Notes name str name of the NodeProxyOptions path str Path is the URL path to use for the current proxy request to node. [optional]","title":"Parameters"},{"location":"#return-type_4","text":"str","title":"Return type"},{"location":"#authorization_4","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_4","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_4","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_delete_node_proxy_with_path","text":"str connect_delete_node_proxy_with_path(name, path, path2=path2) connect DELETE requests to proxy of Node","title":"connect_delete_node_proxy_with_path"},{"location":"#example_5","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the NodeProxyOptions path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the URL path to use for the current proxy request to node. (optional) try: api_response = api_instance.connect_delete_node_proxy_with_path(name, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_delete_node_proxy_with_path: %s\\n\" % e)","title":"Example"},{"location":"#parameters_5","text":"Name Type Description Notes name str name of the NodeProxyOptions path str path to the resource path2 str Path is the URL path to use for the current proxy request to node. [optional]","title":"Parameters"},{"location":"#return-type_5","text":"str","title":"Return type"},{"location":"#authorization_5","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_5","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_5","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_get_namespaced_pod_attach","text":"str connect_get_namespaced_pod_attach(name, namespace, container=container, stderr=stderr, stdin=stdin, stdout=stdout, tty=tty) connect GET requests to attach of Pod","title":"connect_get_namespaced_pod_attach"},{"location":"#example_6","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodAttachOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects container = 'container_example' # str | The container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional) stderr = True # bool | Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true. (optional) stdin = True # bool | Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false. (optional) stdout = True # bool | Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true. (optional) tty = True # bool | TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false. (optional) try: api_response = api_instance.connect_get_namespaced_pod_attach(name, namespace, container=container, stderr=stderr, stdin=stdin, stdout=stdout, tty=tty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_get_namespaced_pod_attach: %s\\n\" % e)","title":"Example"},{"location":"#parameters_6","text":"Name Type Description Notes name str name of the PodAttachOptions namespace str object name and auth scope, such as for teams and projects container str The container in which to execute the command. Defaults to only container if there is only one container in the pod. [optional] stderr bool Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true. [optional] stdin bool Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false. [optional] stdout bool Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true. [optional] tty bool TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false. [optional]","title":"Parameters"},{"location":"#return-type_6","text":"str","title":"Return type"},{"location":"#authorization_6","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_6","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_6","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_get_namespaced_pod_exec","text":"str connect_get_namespaced_pod_exec(name, namespace, command=command, container=container, stderr=stderr, stdin=stdin, stdout=stdout, tty=tty) connect GET requests to exec of Pod","title":"connect_get_namespaced_pod_exec"},{"location":"#example_7","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodExecOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects command = 'command_example' # str | Command is the remote command to execute. argv array. Not executed within a shell. (optional) container = 'container_example' # str | Container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional) stderr = True # bool | Redirect the standard error stream of the pod for this call. Defaults to true. (optional) stdin = True # bool | Redirect the standard input stream of the pod for this call. Defaults to false. (optional) stdout = True # bool | Redirect the standard output stream of the pod for this call. Defaults to true. (optional) tty = True # bool | TTY if true indicates that a tty will be allocated for the exec call. Defaults to false. (optional) try: api_response = api_instance.connect_get_namespaced_pod_exec(name, namespace, command=command, container=container, stderr=stderr, stdin=stdin, stdout=stdout, tty=tty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_get_namespaced_pod_exec: %s\\n\" % e)","title":"Example"},{"location":"#parameters_7","text":"Name Type Description Notes name str name of the PodExecOptions namespace str object name and auth scope, such as for teams and projects command str Command is the remote command to execute. argv array. Not executed within a shell. [optional] container str Container in which to execute the command. Defaults to only container if there is only one container in the pod. [optional] stderr bool Redirect the standard error stream of the pod for this call. Defaults to true. [optional] stdin bool Redirect the standard input stream of the pod for this call. Defaults to false. [optional] stdout bool Redirect the standard output stream of the pod for this call. Defaults to true. [optional] tty bool TTY if true indicates that a tty will be allocated for the exec call. Defaults to false. [optional]","title":"Parameters"},{"location":"#return-type_7","text":"str","title":"Return type"},{"location":"#authorization_7","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_7","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_7","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_get_namespaced_pod_portforward","text":"str connect_get_namespaced_pod_portforward(name, namespace, ports=ports) connect GET requests to portforward of Pod","title":"connect_get_namespaced_pod_portforward"},{"location":"#example_8","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodPortForwardOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects ports = 56 # int | List of ports to forward Required when using WebSockets (optional) try: api_response = api_instance.connect_get_namespaced_pod_portforward(name, namespace, ports=ports) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_get_namespaced_pod_portforward: %s\\n\" % e)","title":"Example"},{"location":"#parameters_8","text":"Name Type Description Notes name str name of the PodPortForwardOptions namespace str object name and auth scope, such as for teams and projects ports int List of ports to forward Required when using WebSockets [optional]","title":"Parameters"},{"location":"#return-type_8","text":"str","title":"Return type"},{"location":"#authorization_8","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_8","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_8","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_get_namespaced_pod_proxy","text":"str connect_get_namespaced_pod_proxy(name, namespace, path=path) connect GET requests to proxy of Pod","title":"connect_get_namespaced_pod_proxy"},{"location":"#example_9","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | Path is the URL path to use for the current proxy request to pod. (optional) try: api_response = api_instance.connect_get_namespaced_pod_proxy(name, namespace, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_get_namespaced_pod_proxy: %s\\n\" % e)","title":"Example"},{"location":"#parameters_9","text":"Name Type Description Notes name str name of the PodProxyOptions namespace str object name and auth scope, such as for teams and projects path str Path is the URL path to use for the current proxy request to pod. [optional]","title":"Parameters"},{"location":"#return-type_9","text":"str","title":"Return type"},{"location":"#authorization_9","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_9","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_9","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_get_namespaced_pod_proxy_with_path","text":"str connect_get_namespaced_pod_proxy_with_path(name, namespace, path, path2=path2) connect GET requests to proxy of Pod","title":"connect_get_namespaced_pod_proxy_with_path"},{"location":"#example_10","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the URL path to use for the current proxy request to pod. (optional) try: api_response = api_instance.connect_get_namespaced_pod_proxy_with_path(name, namespace, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_get_namespaced_pod_proxy_with_path: %s\\n\" % e)","title":"Example"},{"location":"#parameters_10","text":"Name Type Description Notes name str name of the PodProxyOptions namespace str object name and auth scope, such as for teams and projects path str path to the resource path2 str Path is the URL path to use for the current proxy request to pod. [optional]","title":"Parameters"},{"location":"#return-type_10","text":"str","title":"Return type"},{"location":"#authorization_10","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_10","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_10","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_get_namespaced_service_proxy","text":"str connect_get_namespaced_service_proxy(name, namespace, path=path) connect GET requests to proxy of Service","title":"connect_get_namespaced_service_proxy"},{"location":"#example_11","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. (optional) try: api_response = api_instance.connect_get_namespaced_service_proxy(name, namespace, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_get_namespaced_service_proxy: %s\\n\" % e)","title":"Example"},{"location":"#parameters_11","text":"Name Type Description Notes name str name of the ServiceProxyOptions namespace str object name and auth scope, such as for teams and projects path str Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. [optional]","title":"Parameters"},{"location":"#return-type_11","text":"str","title":"Return type"},{"location":"#authorization_11","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_11","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_11","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_get_namespaced_service_proxy_with_path","text":"str connect_get_namespaced_service_proxy_with_path(name, namespace, path, path2=path2) connect GET requests to proxy of Service","title":"connect_get_namespaced_service_proxy_with_path"},{"location":"#example_12","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. (optional) try: api_response = api_instance.connect_get_namespaced_service_proxy_with_path(name, namespace, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_get_namespaced_service_proxy_with_path: %s\\n\" % e)","title":"Example"},{"location":"#parameters_12","text":"Name Type Description Notes name str name of the ServiceProxyOptions namespace str object name and auth scope, such as for teams and projects path str path to the resource path2 str Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. [optional]","title":"Parameters"},{"location":"#return-type_12","text":"str","title":"Return type"},{"location":"#authorization_12","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_12","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_12","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_get_node_proxy","text":"str connect_get_node_proxy(name, path=path) connect GET requests to proxy of Node","title":"connect_get_node_proxy"},{"location":"#example_13","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the NodeProxyOptions path = 'path_example' # str | Path is the URL path to use for the current proxy request to node. (optional) try: api_response = api_instance.connect_get_node_proxy(name, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_get_node_proxy: %s\\n\" % e)","title":"Example"},{"location":"#parameters_13","text":"Name Type Description Notes name str name of the NodeProxyOptions path str Path is the URL path to use for the current proxy request to node. [optional]","title":"Parameters"},{"location":"#return-type_13","text":"str","title":"Return type"},{"location":"#authorization_13","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_13","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_13","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_get_node_proxy_with_path","text":"str connect_get_node_proxy_with_path(name, path, path2=path2) connect GET requests to proxy of Node","title":"connect_get_node_proxy_with_path"},{"location":"#example_14","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the NodeProxyOptions path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the URL path to use for the current proxy request to node. (optional) try: api_response = api_instance.connect_get_node_proxy_with_path(name, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_get_node_proxy_with_path: %s\\n\" % e)","title":"Example"},{"location":"#parameters_14","text":"Name Type Description Notes name str name of the NodeProxyOptions path str path to the resource path2 str Path is the URL path to use for the current proxy request to node. [optional]","title":"Parameters"},{"location":"#return-type_14","text":"str","title":"Return type"},{"location":"#authorization_14","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_14","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_14","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_head_namespaced_pod_proxy","text":"str connect_head_namespaced_pod_proxy(name, namespace, path=path) connect HEAD requests to proxy of Pod","title":"connect_head_namespaced_pod_proxy"},{"location":"#example_15","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | Path is the URL path to use for the current proxy request to pod. (optional) try: api_response = api_instance.connect_head_namespaced_pod_proxy(name, namespace, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_head_namespaced_pod_proxy: %s\\n\" % e)","title":"Example"},{"location":"#parameters_15","text":"Name Type Description Notes name str name of the PodProxyOptions namespace str object name and auth scope, such as for teams and projects path str Path is the URL path to use for the current proxy request to pod. [optional]","title":"Parameters"},{"location":"#return-type_15","text":"str","title":"Return type"},{"location":"#authorization_15","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_15","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_15","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_head_namespaced_pod_proxy_with_path","text":"str connect_head_namespaced_pod_proxy_with_path(name, namespace, path, path2=path2) connect HEAD requests to proxy of Pod","title":"connect_head_namespaced_pod_proxy_with_path"},{"location":"#example_16","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the URL path to use for the current proxy request to pod. (optional) try: api_response = api_instance.connect_head_namespaced_pod_proxy_with_path(name, namespace, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_head_namespaced_pod_proxy_with_path: %s\\n\" % e)","title":"Example"},{"location":"#parameters_16","text":"Name Type Description Notes name str name of the PodProxyOptions namespace str object name and auth scope, such as for teams and projects path str path to the resource path2 str Path is the URL path to use for the current proxy request to pod. [optional]","title":"Parameters"},{"location":"#return-type_16","text":"str","title":"Return type"},{"location":"#authorization_16","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_16","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_16","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_head_namespaced_service_proxy","text":"str connect_head_namespaced_service_proxy(name, namespace, path=path) connect HEAD requests to proxy of Service","title":"connect_head_namespaced_service_proxy"},{"location":"#example_17","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. (optional) try: api_response = api_instance.connect_head_namespaced_service_proxy(name, namespace, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_head_namespaced_service_proxy: %s\\n\" % e)","title":"Example"},{"location":"#parameters_17","text":"Name Type Description Notes name str name of the ServiceProxyOptions namespace str object name and auth scope, such as for teams and projects path str Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. [optional]","title":"Parameters"},{"location":"#return-type_17","text":"str","title":"Return type"},{"location":"#authorization_17","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_17","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_17","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_head_namespaced_service_proxy_with_path","text":"str connect_head_namespaced_service_proxy_with_path(name, namespace, path, path2=path2) connect HEAD requests to proxy of Service","title":"connect_head_namespaced_service_proxy_with_path"},{"location":"#example_18","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. (optional) try: api_response = api_instance.connect_head_namespaced_service_proxy_with_path(name, namespace, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_head_namespaced_service_proxy_with_path: %s\\n\" % e)","title":"Example"},{"location":"#parameters_18","text":"Name Type Description Notes name str name of the ServiceProxyOptions namespace str object name and auth scope, such as for teams and projects path str path to the resource path2 str Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. [optional]","title":"Parameters"},{"location":"#return-type_18","text":"str","title":"Return type"},{"location":"#authorization_18","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_18","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_18","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_head_node_proxy","text":"str connect_head_node_proxy(name, path=path) connect HEAD requests to proxy of Node","title":"connect_head_node_proxy"},{"location":"#example_19","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the NodeProxyOptions path = 'path_example' # str | Path is the URL path to use for the current proxy request to node. (optional) try: api_response = api_instance.connect_head_node_proxy(name, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_head_node_proxy: %s\\n\" % e)","title":"Example"},{"location":"#parameters_19","text":"Name Type Description Notes name str name of the NodeProxyOptions path str Path is the URL path to use for the current proxy request to node. [optional]","title":"Parameters"},{"location":"#return-type_19","text":"str","title":"Return type"},{"location":"#authorization_19","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_19","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_19","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_head_node_proxy_with_path","text":"str connect_head_node_proxy_with_path(name, path, path2=path2) connect HEAD requests to proxy of Node","title":"connect_head_node_proxy_with_path"},{"location":"#example_20","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the NodeProxyOptions path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the URL path to use for the current proxy request to node. (optional) try: api_response = api_instance.connect_head_node_proxy_with_path(name, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_head_node_proxy_with_path: %s\\n\" % e)","title":"Example"},{"location":"#parameters_20","text":"Name Type Description Notes name str name of the NodeProxyOptions path str path to the resource path2 str Path is the URL path to use for the current proxy request to node. [optional]","title":"Parameters"},{"location":"#return-type_20","text":"str","title":"Return type"},{"location":"#authorization_20","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_20","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_20","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_options_namespaced_pod_proxy","text":"str connect_options_namespaced_pod_proxy(name, namespace, path=path) connect OPTIONS requests to proxy of Pod","title":"connect_options_namespaced_pod_proxy"},{"location":"#example_21","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | Path is the URL path to use for the current proxy request to pod. (optional) try: api_response = api_instance.connect_options_namespaced_pod_proxy(name, namespace, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_options_namespaced_pod_proxy: %s\\n\" % e)","title":"Example"},{"location":"#parameters_21","text":"Name Type Description Notes name str name of the PodProxyOptions namespace str object name and auth scope, such as for teams and projects path str Path is the URL path to use for the current proxy request to pod. [optional]","title":"Parameters"},{"location":"#return-type_21","text":"str","title":"Return type"},{"location":"#authorization_21","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_21","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_21","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_options_namespaced_pod_proxy_with_path","text":"str connect_options_namespaced_pod_proxy_with_path(name, namespace, path, path2=path2) connect OPTIONS requests to proxy of Pod","title":"connect_options_namespaced_pod_proxy_with_path"},{"location":"#example_22","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the URL path to use for the current proxy request to pod. (optional) try: api_response = api_instance.connect_options_namespaced_pod_proxy_with_path(name, namespace, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_options_namespaced_pod_proxy_with_path: %s\\n\" % e)","title":"Example"},{"location":"#parameters_22","text":"Name Type Description Notes name str name of the PodProxyOptions namespace str object name and auth scope, such as for teams and projects path str path to the resource path2 str Path is the URL path to use for the current proxy request to pod. [optional]","title":"Parameters"},{"location":"#return-type_22","text":"str","title":"Return type"},{"location":"#authorization_22","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_22","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_22","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_options_namespaced_service_proxy","text":"str connect_options_namespaced_service_proxy(name, namespace, path=path) connect OPTIONS requests to proxy of Service","title":"connect_options_namespaced_service_proxy"},{"location":"#example_23","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. (optional) try: api_response = api_instance.connect_options_namespaced_service_proxy(name, namespace, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_options_namespaced_service_proxy: %s\\n\" % e)","title":"Example"},{"location":"#parameters_23","text":"Name Type Description Notes name str name of the ServiceProxyOptions namespace str object name and auth scope, such as for teams and projects path str Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. [optional]","title":"Parameters"},{"location":"#return-type_23","text":"str","title":"Return type"},{"location":"#authorization_23","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_23","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_23","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_options_namespaced_service_proxy_with_path","text":"str connect_options_namespaced_service_proxy_with_path(name, namespace, path, path2=path2) connect OPTIONS requests to proxy of Service","title":"connect_options_namespaced_service_proxy_with_path"},{"location":"#example_24","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. (optional) try: api_response = api_instance.connect_options_namespaced_service_proxy_with_path(name, namespace, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_options_namespaced_service_proxy_with_path: %s\\n\" % e)","title":"Example"},{"location":"#parameters_24","text":"Name Type Description Notes name str name of the ServiceProxyOptions namespace str object name and auth scope, such as for teams and projects path str path to the resource path2 str Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. [optional]","title":"Parameters"},{"location":"#return-type_24","text":"str","title":"Return type"},{"location":"#authorization_24","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_24","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_24","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_options_node_proxy","text":"str connect_options_node_proxy(name, path=path) connect OPTIONS requests to proxy of Node","title":"connect_options_node_proxy"},{"location":"#example_25","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the NodeProxyOptions path = 'path_example' # str | Path is the URL path to use for the current proxy request to node. (optional) try: api_response = api_instance.connect_options_node_proxy(name, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_options_node_proxy: %s\\n\" % e)","title":"Example"},{"location":"#parameters_25","text":"Name Type Description Notes name str name of the NodeProxyOptions path str Path is the URL path to use for the current proxy request to node. [optional]","title":"Parameters"},{"location":"#return-type_25","text":"str","title":"Return type"},{"location":"#authorization_25","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_25","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_25","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_options_node_proxy_with_path","text":"str connect_options_node_proxy_with_path(name, path, path2=path2) connect OPTIONS requests to proxy of Node","title":"connect_options_node_proxy_with_path"},{"location":"#example_26","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the NodeProxyOptions path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the URL path to use for the current proxy request to node. (optional) try: api_response = api_instance.connect_options_node_proxy_with_path(name, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_options_node_proxy_with_path: %s\\n\" % e)","title":"Example"},{"location":"#parameters_26","text":"Name Type Description Notes name str name of the NodeProxyOptions path str path to the resource path2 str Path is the URL path to use for the current proxy request to node. [optional]","title":"Parameters"},{"location":"#return-type_26","text":"str","title":"Return type"},{"location":"#authorization_26","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_26","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_26","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_patch_namespaced_pod_proxy","text":"str connect_patch_namespaced_pod_proxy(name, namespace, path=path) connect PATCH requests to proxy of Pod","title":"connect_patch_namespaced_pod_proxy"},{"location":"#example_27","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | Path is the URL path to use for the current proxy request to pod. (optional) try: api_response = api_instance.connect_patch_namespaced_pod_proxy(name, namespace, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_patch_namespaced_pod_proxy: %s\\n\" % e)","title":"Example"},{"location":"#parameters_27","text":"Name Type Description Notes name str name of the PodProxyOptions namespace str object name and auth scope, such as for teams and projects path str Path is the URL path to use for the current proxy request to pod. [optional]","title":"Parameters"},{"location":"#return-type_27","text":"str","title":"Return type"},{"location":"#authorization_27","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_27","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_27","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_patch_namespaced_pod_proxy_with_path","text":"str connect_patch_namespaced_pod_proxy_with_path(name, namespace, path, path2=path2) connect PATCH requests to proxy of Pod","title":"connect_patch_namespaced_pod_proxy_with_path"},{"location":"#example_28","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the URL path to use for the current proxy request to pod. (optional) try: api_response = api_instance.connect_patch_namespaced_pod_proxy_with_path(name, namespace, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_patch_namespaced_pod_proxy_with_path: %s\\n\" % e)","title":"Example"},{"location":"#parameters_28","text":"Name Type Description Notes name str name of the PodProxyOptions namespace str object name and auth scope, such as for teams and projects path str path to the resource path2 str Path is the URL path to use for the current proxy request to pod. [optional]","title":"Parameters"},{"location":"#return-type_28","text":"str","title":"Return type"},{"location":"#authorization_28","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_28","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_28","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_patch_namespaced_service_proxy","text":"str connect_patch_namespaced_service_proxy(name, namespace, path=path) connect PATCH requests to proxy of Service","title":"connect_patch_namespaced_service_proxy"},{"location":"#example_29","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. (optional) try: api_response = api_instance.connect_patch_namespaced_service_proxy(name, namespace, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_patch_namespaced_service_proxy: %s\\n\" % e)","title":"Example"},{"location":"#parameters_29","text":"Name Type Description Notes name str name of the ServiceProxyOptions namespace str object name and auth scope, such as for teams and projects path str Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. [optional]","title":"Parameters"},{"location":"#return-type_29","text":"str","title":"Return type"},{"location":"#authorization_29","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_29","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_29","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_patch_namespaced_service_proxy_with_path","text":"str connect_patch_namespaced_service_proxy_with_path(name, namespace, path, path2=path2) connect PATCH requests to proxy of Service","title":"connect_patch_namespaced_service_proxy_with_path"},{"location":"#example_30","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. (optional) try: api_response = api_instance.connect_patch_namespaced_service_proxy_with_path(name, namespace, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_patch_namespaced_service_proxy_with_path: %s\\n\" % e)","title":"Example"},{"location":"#parameters_30","text":"Name Type Description Notes name str name of the ServiceProxyOptions namespace str object name and auth scope, such as for teams and projects path str path to the resource path2 str Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. [optional]","title":"Parameters"},{"location":"#return-type_30","text":"str","title":"Return type"},{"location":"#authorization_30","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_30","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_30","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_patch_node_proxy","text":"str connect_patch_node_proxy(name, path=path) connect PATCH requests to proxy of Node","title":"connect_patch_node_proxy"},{"location":"#example_31","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the NodeProxyOptions path = 'path_example' # str | Path is the URL path to use for the current proxy request to node. (optional) try: api_response = api_instance.connect_patch_node_proxy(name, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_patch_node_proxy: %s\\n\" % e)","title":"Example"},{"location":"#parameters_31","text":"Name Type Description Notes name str name of the NodeProxyOptions path str Path is the URL path to use for the current proxy request to node. [optional]","title":"Parameters"},{"location":"#return-type_31","text":"str","title":"Return type"},{"location":"#authorization_31","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_31","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_31","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_patch_node_proxy_with_path","text":"str connect_patch_node_proxy_with_path(name, path, path2=path2) connect PATCH requests to proxy of Node","title":"connect_patch_node_proxy_with_path"},{"location":"#example_32","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the NodeProxyOptions path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the URL path to use for the current proxy request to node. (optional) try: api_response = api_instance.connect_patch_node_proxy_with_path(name, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_patch_node_proxy_with_path: %s\\n\" % e)","title":"Example"},{"location":"#parameters_32","text":"Name Type Description Notes name str name of the NodeProxyOptions path str path to the resource path2 str Path is the URL path to use for the current proxy request to node. [optional]","title":"Parameters"},{"location":"#return-type_32","text":"str","title":"Return type"},{"location":"#authorization_32","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_32","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_32","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_post_namespaced_pod_attach","text":"str connect_post_namespaced_pod_attach(name, namespace, container=container, stderr=stderr, stdin=stdin, stdout=stdout, tty=tty) connect POST requests to attach of Pod","title":"connect_post_namespaced_pod_attach"},{"location":"#example_33","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodAttachOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects container = 'container_example' # str | The container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional) stderr = True # bool | Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true. (optional) stdin = True # bool | Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false. (optional) stdout = True # bool | Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true. (optional) tty = True # bool | TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false. (optional) try: api_response = api_instance.connect_post_namespaced_pod_attach(name, namespace, container=container, stderr=stderr, stdin=stdin, stdout=stdout, tty=tty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_post_namespaced_pod_attach: %s\\n\" % e)","title":"Example"},{"location":"#parameters_33","text":"Name Type Description Notes name str name of the PodAttachOptions namespace str object name and auth scope, such as for teams and projects container str The container in which to execute the command. Defaults to only container if there is only one container in the pod. [optional] stderr bool Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true. [optional] stdin bool Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false. [optional] stdout bool Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true. [optional] tty bool TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false. [optional]","title":"Parameters"},{"location":"#return-type_33","text":"str","title":"Return type"},{"location":"#authorization_33","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_33","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_33","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_post_namespaced_pod_exec","text":"str connect_post_namespaced_pod_exec(name, namespace, command=command, container=container, stderr=stderr, stdin=stdin, stdout=stdout, tty=tty) connect POST requests to exec of Pod","title":"connect_post_namespaced_pod_exec"},{"location":"#example_34","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodExecOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects command = 'command_example' # str | Command is the remote command to execute. argv array. Not executed within a shell. (optional) container = 'container_example' # str | Container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional) stderr = True # bool | Redirect the standard error stream of the pod for this call. Defaults to true. (optional) stdin = True # bool | Redirect the standard input stream of the pod for this call. Defaults to false. (optional) stdout = True # bool | Redirect the standard output stream of the pod for this call. Defaults to true. (optional) tty = True # bool | TTY if true indicates that a tty will be allocated for the exec call. Defaults to false. (optional) try: api_response = api_instance.connect_post_namespaced_pod_exec(name, namespace, command=command, container=container, stderr=stderr, stdin=stdin, stdout=stdout, tty=tty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_post_namespaced_pod_exec: %s\\n\" % e)","title":"Example"},{"location":"#parameters_34","text":"Name Type Description Notes name str name of the PodExecOptions namespace str object name and auth scope, such as for teams and projects command str Command is the remote command to execute. argv array. Not executed within a shell. [optional] container str Container in which to execute the command. Defaults to only container if there is only one container in the pod. [optional] stderr bool Redirect the standard error stream of the pod for this call. Defaults to true. [optional] stdin bool Redirect the standard input stream of the pod for this call. Defaults to false. [optional] stdout bool Redirect the standard output stream of the pod for this call. Defaults to true. [optional] tty bool TTY if true indicates that a tty will be allocated for the exec call. Defaults to false. [optional]","title":"Parameters"},{"location":"#return-type_34","text":"str","title":"Return type"},{"location":"#authorization_34","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_34","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_34","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_post_namespaced_pod_portforward","text":"str connect_post_namespaced_pod_portforward(name, namespace, ports=ports) connect POST requests to portforward of Pod","title":"connect_post_namespaced_pod_portforward"},{"location":"#example_35","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodPortForwardOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects ports = 56 # int | List of ports to forward Required when using WebSockets (optional) try: api_response = api_instance.connect_post_namespaced_pod_portforward(name, namespace, ports=ports) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_post_namespaced_pod_portforward: %s\\n\" % e)","title":"Example"},{"location":"#parameters_35","text":"Name Type Description Notes name str name of the PodPortForwardOptions namespace str object name and auth scope, such as for teams and projects ports int List of ports to forward Required when using WebSockets [optional]","title":"Parameters"},{"location":"#return-type_35","text":"str","title":"Return type"},{"location":"#authorization_35","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_35","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_35","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_post_namespaced_pod_proxy","text":"str connect_post_namespaced_pod_proxy(name, namespace, path=path) connect POST requests to proxy of Pod","title":"connect_post_namespaced_pod_proxy"},{"location":"#example_36","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | Path is the URL path to use for the current proxy request to pod. (optional) try: api_response = api_instance.connect_post_namespaced_pod_proxy(name, namespace, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_post_namespaced_pod_proxy: %s\\n\" % e)","title":"Example"},{"location":"#parameters_36","text":"Name Type Description Notes name str name of the PodProxyOptions namespace str object name and auth scope, such as for teams and projects path str Path is the URL path to use for the current proxy request to pod. [optional]","title":"Parameters"},{"location":"#return-type_36","text":"str","title":"Return type"},{"location":"#authorization_36","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_36","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_36","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_post_namespaced_pod_proxy_with_path","text":"str connect_post_namespaced_pod_proxy_with_path(name, namespace, path, path2=path2) connect POST requests to proxy of Pod","title":"connect_post_namespaced_pod_proxy_with_path"},{"location":"#example_37","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the URL path to use for the current proxy request to pod. (optional) try: api_response = api_instance.connect_post_namespaced_pod_proxy_with_path(name, namespace, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_post_namespaced_pod_proxy_with_path: %s\\n\" % e)","title":"Example"},{"location":"#parameters_37","text":"Name Type Description Notes name str name of the PodProxyOptions namespace str object name and auth scope, such as for teams and projects path str path to the resource path2 str Path is the URL path to use for the current proxy request to pod. [optional]","title":"Parameters"},{"location":"#return-type_37","text":"str","title":"Return type"},{"location":"#authorization_37","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_37","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_37","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_post_namespaced_service_proxy","text":"str connect_post_namespaced_service_proxy(name, namespace, path=path) connect POST requests to proxy of Service","title":"connect_post_namespaced_service_proxy"},{"location":"#example_38","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. (optional) try: api_response = api_instance.connect_post_namespaced_service_proxy(name, namespace, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_post_namespaced_service_proxy: %s\\n\" % e)","title":"Example"},{"location":"#parameters_38","text":"Name Type Description Notes name str name of the ServiceProxyOptions namespace str object name and auth scope, such as for teams and projects path str Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. [optional]","title":"Parameters"},{"location":"#return-type_38","text":"str","title":"Return type"},{"location":"#authorization_38","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_38","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_38","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_post_namespaced_service_proxy_with_path","text":"str connect_post_namespaced_service_proxy_with_path(name, namespace, path, path2=path2) connect POST requests to proxy of Service","title":"connect_post_namespaced_service_proxy_with_path"},{"location":"#example_39","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. (optional) try: api_response = api_instance.connect_post_namespaced_service_proxy_with_path(name, namespace, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_post_namespaced_service_proxy_with_path: %s\\n\" % e)","title":"Example"},{"location":"#parameters_39","text":"Name Type Description Notes name str name of the ServiceProxyOptions namespace str object name and auth scope, such as for teams and projects path str path to the resource path2 str Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. [optional]","title":"Parameters"},{"location":"#return-type_39","text":"str","title":"Return type"},{"location":"#authorization_39","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_39","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_39","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_post_node_proxy","text":"str connect_post_node_proxy(name, path=path) connect POST requests to proxy of Node","title":"connect_post_node_proxy"},{"location":"#example_40","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the NodeProxyOptions path = 'path_example' # str | Path is the URL path to use for the current proxy request to node. (optional) try: api_response = api_instance.connect_post_node_proxy(name, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_post_node_proxy: %s\\n\" % e)","title":"Example"},{"location":"#parameters_40","text":"Name Type Description Notes name str name of the NodeProxyOptions path str Path is the URL path to use for the current proxy request to node. [optional]","title":"Parameters"},{"location":"#return-type_40","text":"str","title":"Return type"},{"location":"#authorization_40","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_40","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_40","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_post_node_proxy_with_path","text":"str connect_post_node_proxy_with_path(name, path, path2=path2) connect POST requests to proxy of Node","title":"connect_post_node_proxy_with_path"},{"location":"#example_41","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the NodeProxyOptions path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the URL path to use for the current proxy request to node. (optional) try: api_response = api_instance.connect_post_node_proxy_with_path(name, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_post_node_proxy_with_path: %s\\n\" % e)","title":"Example"},{"location":"#parameters_41","text":"Name Type Description Notes name str name of the NodeProxyOptions path str path to the resource path2 str Path is the URL path to use for the current proxy request to node. [optional]","title":"Parameters"},{"location":"#return-type_41","text":"str","title":"Return type"},{"location":"#authorization_41","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_41","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_41","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_put_namespaced_pod_proxy","text":"str connect_put_namespaced_pod_proxy(name, namespace, path=path) connect PUT requests to proxy of Pod","title":"connect_put_namespaced_pod_proxy"},{"location":"#example_42","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | Path is the URL path to use for the current proxy request to pod. (optional) try: api_response = api_instance.connect_put_namespaced_pod_proxy(name, namespace, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_put_namespaced_pod_proxy: %s\\n\" % e)","title":"Example"},{"location":"#parameters_42","text":"Name Type Description Notes name str name of the PodProxyOptions namespace str object name and auth scope, such as for teams and projects path str Path is the URL path to use for the current proxy request to pod. [optional]","title":"Parameters"},{"location":"#return-type_42","text":"str","title":"Return type"},{"location":"#authorization_42","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_42","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_42","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_put_namespaced_pod_proxy_with_path","text":"str connect_put_namespaced_pod_proxy_with_path(name, namespace, path, path2=path2) connect PUT requests to proxy of Pod","title":"connect_put_namespaced_pod_proxy_with_path"},{"location":"#example_43","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the URL path to use for the current proxy request to pod. (optional) try: api_response = api_instance.connect_put_namespaced_pod_proxy_with_path(name, namespace, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_put_namespaced_pod_proxy_with_path: %s\\n\" % e)","title":"Example"},{"location":"#parameters_43","text":"Name Type Description Notes name str name of the PodProxyOptions namespace str object name and auth scope, such as for teams and projects path str path to the resource path2 str Path is the URL path to use for the current proxy request to pod. [optional]","title":"Parameters"},{"location":"#return-type_43","text":"str","title":"Return type"},{"location":"#authorization_43","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_43","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_43","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_put_namespaced_service_proxy","text":"str connect_put_namespaced_service_proxy(name, namespace, path=path) connect PUT requests to proxy of Service","title":"connect_put_namespaced_service_proxy"},{"location":"#example_44","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. (optional) try: api_response = api_instance.connect_put_namespaced_service_proxy(name, namespace, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_put_namespaced_service_proxy: %s\\n\" % e)","title":"Example"},{"location":"#parameters_44","text":"Name Type Description Notes name str name of the ServiceProxyOptions namespace str object name and auth scope, such as for teams and projects path str Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. [optional]","title":"Parameters"},{"location":"#return-type_44","text":"str","title":"Return type"},{"location":"#authorization_44","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_44","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_44","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_put_namespaced_service_proxy_with_path","text":"str connect_put_namespaced_service_proxy_with_path(name, namespace, path, path2=path2) connect PUT requests to proxy of Service","title":"connect_put_namespaced_service_proxy_with_path"},{"location":"#example_45","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceProxyOptions namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. (optional) try: api_response = api_instance.connect_put_namespaced_service_proxy_with_path(name, namespace, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_put_namespaced_service_proxy_with_path: %s\\n\" % e)","title":"Example"},{"location":"#parameters_45","text":"Name Type Description Notes name str name of the ServiceProxyOptions namespace str object name and auth scope, such as for teams and projects path str path to the resource path2 str Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy. [optional]","title":"Parameters"},{"location":"#return-type_45","text":"str","title":"Return type"},{"location":"#authorization_45","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_45","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_45","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_put_node_proxy","text":"str connect_put_node_proxy(name, path=path) connect PUT requests to proxy of Node","title":"connect_put_node_proxy"},{"location":"#example_46","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the NodeProxyOptions path = 'path_example' # str | Path is the URL path to use for the current proxy request to node. (optional) try: api_response = api_instance.connect_put_node_proxy(name, path=path) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_put_node_proxy: %s\\n\" % e)","title":"Example"},{"location":"#parameters_46","text":"Name Type Description Notes name str name of the NodeProxyOptions path str Path is the URL path to use for the current proxy request to node. [optional]","title":"Parameters"},{"location":"#return-type_46","text":"str","title":"Return type"},{"location":"#authorization_46","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_46","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_46","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#connect_put_node_proxy_with_path","text":"str connect_put_node_proxy_with_path(name, path, path2=path2) connect PUT requests to proxy of Node","title":"connect_put_node_proxy_with_path"},{"location":"#example_47","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the NodeProxyOptions path = 'path_example' # str | path to the resource path2 = 'path_example' # str | Path is the URL path to use for the current proxy request to node. (optional) try: api_response = api_instance.connect_put_node_proxy_with_path(name, path, path2=path2) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->connect_put_node_proxy_with_path: %s\\n\" % e)","title":"Example"},{"location":"#parameters_47","text":"Name Type Description Notes name str name of the NodeProxyOptions path str path to the resource path2 str Path is the URL path to use for the current proxy request to node. [optional]","title":"Parameters"},{"location":"#return-type_47","text":"str","title":"Return type"},{"location":"#authorization_47","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_47","text":"Content-Type : Not defined Accept : /","title":"HTTP request headers"},{"location":"#http-response-details_47","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#create_namespace","text":"V1Namespace create_namespace(body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) create a Namespace","title":"create_namespace"},{"location":"#example_48","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) body = kubernetes.client.V1Namespace() # V1Namespace | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.create_namespace(body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_namespace: %s\\n\" % e)","title":"Example"},{"location":"#parameters_48","text":"Name Type Description Notes body V1Namespace pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_48","text":"V1Namespace","title":"Return type"},{"location":"#authorization_48","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_48","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_48","text":"Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#create_namespaced_binding","text":"V1Binding create_namespaced_binding(namespace, body, dry_run=dry_run, field_manager=field_manager, pretty=pretty) create a Binding","title":"create_namespaced_binding"},{"location":"#example_49","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1Binding() # V1Binding | dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) try: api_response = api_instance.create_namespaced_binding(namespace, body, dry_run=dry_run, field_manager=field_manager, pretty=pretty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_namespaced_binding: %s\\n\" % e)","title":"Example"},{"location":"#parameters_49","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects body V1Binding dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] pretty str If 'true', then the output is pretty printed. [optional]","title":"Parameters"},{"location":"#return-type_49","text":"V1Binding","title":"Return type"},{"location":"#authorization_49","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_49","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_49","text":"Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#create_namespaced_config_map","text":"V1ConfigMap create_namespaced_config_map(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) create a ConfigMap","title":"create_namespaced_config_map"},{"location":"#example_50","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1ConfigMap() # V1ConfigMap | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.create_namespaced_config_map(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_namespaced_config_map: %s\\n\" % e)","title":"Example"},{"location":"#parameters_50","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects body V1ConfigMap pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_50","text":"V1ConfigMap","title":"Return type"},{"location":"#authorization_50","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_50","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_50","text":"Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#create_namespaced_endpoints","text":"V1Endpoints create_namespaced_endpoints(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) create Endpoints","title":"create_namespaced_endpoints"},{"location":"#example_51","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1Endpoints() # V1Endpoints | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.create_namespaced_endpoints(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_namespaced_endpoints: %s\\n\" % e)","title":"Example"},{"location":"#parameters_51","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects body V1Endpoints pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_51","text":"V1Endpoints","title":"Return type"},{"location":"#authorization_51","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_51","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_51","text":"Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#create_namespaced_event","text":"V1Event create_namespaced_event(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) create an Event","title":"create_namespaced_event"},{"location":"#example_52","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1Event() # V1Event | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.create_namespaced_event(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_namespaced_event: %s\\n\" % e)","title":"Example"},{"location":"#parameters_52","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects body V1Event pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_52","text":"V1Event","title":"Return type"},{"location":"#authorization_52","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_52","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_52","text":"Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#create_namespaced_limit_range","text":"V1LimitRange create_namespaced_limit_range(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) create a LimitRange","title":"create_namespaced_limit_range"},{"location":"#example_53","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1LimitRange() # V1LimitRange | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.create_namespaced_limit_range(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_namespaced_limit_range: %s\\n\" % e)","title":"Example"},{"location":"#parameters_53","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects body V1LimitRange pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_53","text":"V1LimitRange","title":"Return type"},{"location":"#authorization_53","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_53","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_53","text":"Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#create_namespaced_persistent_volume_claim","text":"V1PersistentVolumeClaim create_namespaced_persistent_volume_claim(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) create a PersistentVolumeClaim","title":"create_namespaced_persistent_volume_claim"},{"location":"#example_54","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1PersistentVolumeClaim() # V1PersistentVolumeClaim | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.create_namespaced_persistent_volume_claim(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_namespaced_persistent_volume_claim: %s\\n\" % e)","title":"Example"},{"location":"#parameters_54","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects body V1PersistentVolumeClaim pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_54","text":"V1PersistentVolumeClaim","title":"Return type"},{"location":"#authorization_54","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_54","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_54","text":"Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#create_namespaced_pod","text":"V1Pod create_namespaced_pod(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) create a Pod","title":"create_namespaced_pod"},{"location":"#example_55","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1Pod() # V1Pod | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.create_namespaced_pod(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_namespaced_pod: %s\\n\" % e)","title":"Example"},{"location":"#parameters_55","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects body V1Pod pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_55","text":"V1Pod","title":"Return type"},{"location":"#authorization_55","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_55","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_55","text":"Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#create_namespaced_pod_binding","text":"V1Binding create_namespaced_pod_binding(name, namespace, body, dry_run=dry_run, field_manager=field_manager, pretty=pretty) create binding of a Pod","title":"create_namespaced_pod_binding"},{"location":"#example_56","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Binding namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1Binding() # V1Binding | dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) try: api_response = api_instance.create_namespaced_pod_binding(name, namespace, body, dry_run=dry_run, field_manager=field_manager, pretty=pretty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_namespaced_pod_binding: %s\\n\" % e)","title":"Example"},{"location":"#parameters_56","text":"Name Type Description Notes name str name of the Binding namespace str object name and auth scope, such as for teams and projects body V1Binding dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] pretty str If 'true', then the output is pretty printed. [optional]","title":"Parameters"},{"location":"#return-type_56","text":"V1Binding","title":"Return type"},{"location":"#authorization_56","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_56","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_56","text":"Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#create_namespaced_pod_eviction","text":"V1beta1Eviction create_namespaced_pod_eviction(name, namespace, body, dry_run=dry_run, field_manager=field_manager, pretty=pretty) create eviction of a Pod","title":"create_namespaced_pod_eviction"},{"location":"#example_57","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Eviction namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1beta1Eviction() # V1beta1Eviction | dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) try: api_response = api_instance.create_namespaced_pod_eviction(name, namespace, body, dry_run=dry_run, field_manager=field_manager, pretty=pretty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_namespaced_pod_eviction: %s\\n\" % e)","title":"Example"},{"location":"#parameters_57","text":"Name Type Description Notes name str name of the Eviction namespace str object name and auth scope, such as for teams and projects body V1beta1Eviction dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] pretty str If 'true', then the output is pretty printed. [optional]","title":"Parameters"},{"location":"#return-type_57","text":"V1beta1Eviction","title":"Return type"},{"location":"#authorization_57","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_57","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_57","text":"Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#create_namespaced_pod_template","text":"V1PodTemplate create_namespaced_pod_template(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) create a PodTemplate","title":"create_namespaced_pod_template"},{"location":"#example_58","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1PodTemplate() # V1PodTemplate | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.create_namespaced_pod_template(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_namespaced_pod_template: %s\\n\" % e)","title":"Example"},{"location":"#parameters_58","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects body V1PodTemplate pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_58","text":"V1PodTemplate","title":"Return type"},{"location":"#authorization_58","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_58","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_58","text":"Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#create_namespaced_replication_controller","text":"V1ReplicationController create_namespaced_replication_controller(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) create a ReplicationController","title":"create_namespaced_replication_controller"},{"location":"#example_59","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1ReplicationController() # V1ReplicationController | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.create_namespaced_replication_controller(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_namespaced_replication_controller: %s\\n\" % e)","title":"Example"},{"location":"#parameters_59","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects body V1ReplicationController pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_59","text":"V1ReplicationController","title":"Return type"},{"location":"#authorization_59","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_59","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_59","text":"Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#create_namespaced_resource_quota","text":"V1ResourceQuota create_namespaced_resource_quota(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) create a ResourceQuota","title":"create_namespaced_resource_quota"},{"location":"#example_60","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1ResourceQuota() # V1ResourceQuota | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.create_namespaced_resource_quota(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_namespaced_resource_quota: %s\\n\" % e)","title":"Example"},{"location":"#parameters_60","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects body V1ResourceQuota pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_60","text":"V1ResourceQuota","title":"Return type"},{"location":"#authorization_60","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_60","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_60","text":"Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#create_namespaced_secret","text":"V1Secret create_namespaced_secret(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) create a Secret","title":"create_namespaced_secret"},{"location":"#example_61","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1Secret() # V1Secret | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.create_namespaced_secret(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_namespaced_secret: %s\\n\" % e)","title":"Example"},{"location":"#parameters_61","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects body V1Secret pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_61","text":"V1Secret","title":"Return type"},{"location":"#authorization_61","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_61","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_61","text":"Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#create_namespaced_service","text":"V1Service create_namespaced_service(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) create a Service","title":"create_namespaced_service"},{"location":"#example_62","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1Service() # V1Service | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.create_namespaced_service(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_namespaced_service: %s\\n\" % e)","title":"Example"},{"location":"#parameters_62","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects body V1Service pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_62","text":"V1Service","title":"Return type"},{"location":"#authorization_62","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_62","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_62","text":"Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#create_namespaced_service_account","text":"V1ServiceAccount create_namespaced_service_account(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) create a ServiceAccount","title":"create_namespaced_service_account"},{"location":"#example_63","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1ServiceAccount() # V1ServiceAccount | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.create_namespaced_service_account(namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_namespaced_service_account: %s\\n\" % e)","title":"Example"},{"location":"#parameters_63","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects body V1ServiceAccount pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_63","text":"V1ServiceAccount","title":"Return type"},{"location":"#authorization_63","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_63","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_63","text":"Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#create_namespaced_service_account_token","text":"V1TokenRequest create_namespaced_service_account_token(name, namespace, body, dry_run=dry_run, field_manager=field_manager, pretty=pretty) create token of a ServiceAccount","title":"create_namespaced_service_account_token"},{"location":"#example_64","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the TokenRequest namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1TokenRequest() # V1TokenRequest | dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) try: api_response = api_instance.create_namespaced_service_account_token(name, namespace, body, dry_run=dry_run, field_manager=field_manager, pretty=pretty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_namespaced_service_account_token: %s\\n\" % e)","title":"Example"},{"location":"#parameters_64","text":"Name Type Description Notes name str name of the TokenRequest namespace str object name and auth scope, such as for teams and projects body V1TokenRequest dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] pretty str If 'true', then the output is pretty printed. [optional]","title":"Parameters"},{"location":"#return-type_64","text":"V1TokenRequest","title":"Return type"},{"location":"#authorization_64","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_64","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_64","text":"Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#create_node","text":"V1Node create_node(body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) create a Node","title":"create_node"},{"location":"#example_65","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) body = kubernetes.client.V1Node() # V1Node | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.create_node(body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_node: %s\\n\" % e)","title":"Example"},{"location":"#parameters_65","text":"Name Type Description Notes body V1Node pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_65","text":"V1Node","title":"Return type"},{"location":"#authorization_65","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_65","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_65","text":"Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#create_persistent_volume","text":"V1PersistentVolume create_persistent_volume(body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) create a PersistentVolume","title":"create_persistent_volume"},{"location":"#example_66","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) body = kubernetes.client.V1PersistentVolume() # V1PersistentVolume | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.create_persistent_volume(body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->create_persistent_volume: %s\\n\" % e)","title":"Example"},{"location":"#parameters_66","text":"Name Type Description Notes body V1PersistentVolume pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_66","text":"V1PersistentVolume","title":"Return type"},{"location":"#authorization_66","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_66","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_66","text":"Status code Description Response headers 200 OK - 201 Created - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#delete_collection_namespaced_config_map","text":"V1Status delete_collection_namespaced_config_map(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) delete collection of ConfigMap","title":"delete_collection_namespaced_config_map"},{"location":"#example_67","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_collection_namespaced_config_map(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_collection_namespaced_config_map: %s\\n\" % e)","title":"Example"},{"location":"#parameters_67","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] body V1DeleteOptions [optional]","title":"Parameters"},{"location":"#return-type_67","text":"V1Status","title":"Return type"},{"location":"#authorization_67","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_67","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_67","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#delete_collection_namespaced_endpoints","text":"V1Status delete_collection_namespaced_endpoints(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) delete collection of Endpoints","title":"delete_collection_namespaced_endpoints"},{"location":"#example_68","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_collection_namespaced_endpoints(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_collection_namespaced_endpoints: %s\\n\" % e)","title":"Example"},{"location":"#parameters_68","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] body V1DeleteOptions [optional]","title":"Parameters"},{"location":"#return-type_68","text":"V1Status","title":"Return type"},{"location":"#authorization_68","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_68","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_68","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#delete_collection_namespaced_event","text":"V1Status delete_collection_namespaced_event(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) delete collection of Event","title":"delete_collection_namespaced_event"},{"location":"#example_69","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_collection_namespaced_event(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_collection_namespaced_event: %s\\n\" % e)","title":"Example"},{"location":"#parameters_69","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] body V1DeleteOptions [optional]","title":"Parameters"},{"location":"#return-type_69","text":"V1Status","title":"Return type"},{"location":"#authorization_69","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_69","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_69","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#delete_collection_namespaced_limit_range","text":"V1Status delete_collection_namespaced_limit_range(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) delete collection of LimitRange","title":"delete_collection_namespaced_limit_range"},{"location":"#example_70","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_collection_namespaced_limit_range(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_collection_namespaced_limit_range: %s\\n\" % e)","title":"Example"},{"location":"#parameters_70","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] body V1DeleteOptions [optional]","title":"Parameters"},{"location":"#return-type_70","text":"V1Status","title":"Return type"},{"location":"#authorization_70","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_70","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_70","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#delete_collection_namespaced_persistent_volume_claim","text":"V1Status delete_collection_namespaced_persistent_volume_claim(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) delete collection of PersistentVolumeClaim","title":"delete_collection_namespaced_persistent_volume_claim"},{"location":"#example_71","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_collection_namespaced_persistent_volume_claim(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_collection_namespaced_persistent_volume_claim: %s\\n\" % e)","title":"Example"},{"location":"#parameters_71","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] body V1DeleteOptions [optional]","title":"Parameters"},{"location":"#return-type_71","text":"V1Status","title":"Return type"},{"location":"#authorization_71","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_71","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_71","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#delete_collection_namespaced_pod","text":"V1Status delete_collection_namespaced_pod(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) delete collection of Pod","title":"delete_collection_namespaced_pod"},{"location":"#example_72","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_collection_namespaced_pod(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_collection_namespaced_pod: %s\\n\" % e)","title":"Example"},{"location":"#parameters_72","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] body V1DeleteOptions [optional]","title":"Parameters"},{"location":"#return-type_72","text":"V1Status","title":"Return type"},{"location":"#authorization_72","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_72","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_72","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#delete_collection_namespaced_pod_template","text":"V1Status delete_collection_namespaced_pod_template(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) delete collection of PodTemplate","title":"delete_collection_namespaced_pod_template"},{"location":"#example_73","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_collection_namespaced_pod_template(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_collection_namespaced_pod_template: %s\\n\" % e)","title":"Example"},{"location":"#parameters_73","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] body V1DeleteOptions [optional]","title":"Parameters"},{"location":"#return-type_73","text":"V1Status","title":"Return type"},{"location":"#authorization_73","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_73","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_73","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#delete_collection_namespaced_replication_controller","text":"V1Status delete_collection_namespaced_replication_controller(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) delete collection of ReplicationController","title":"delete_collection_namespaced_replication_controller"},{"location":"#example_74","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_collection_namespaced_replication_controller(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_collection_namespaced_replication_controller: %s\\n\" % e)","title":"Example"},{"location":"#parameters_74","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] body V1DeleteOptions [optional]","title":"Parameters"},{"location":"#return-type_74","text":"V1Status","title":"Return type"},{"location":"#authorization_74","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_74","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_74","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#delete_collection_namespaced_resource_quota","text":"V1Status delete_collection_namespaced_resource_quota(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) delete collection of ResourceQuota","title":"delete_collection_namespaced_resource_quota"},{"location":"#example_75","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_collection_namespaced_resource_quota(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_collection_namespaced_resource_quota: %s\\n\" % e)","title":"Example"},{"location":"#parameters_75","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] body V1DeleteOptions [optional]","title":"Parameters"},{"location":"#return-type_75","text":"V1Status","title":"Return type"},{"location":"#authorization_75","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_75","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_75","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#delete_collection_namespaced_secret","text":"V1Status delete_collection_namespaced_secret(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) delete collection of Secret","title":"delete_collection_namespaced_secret"},{"location":"#example_76","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_collection_namespaced_secret(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_collection_namespaced_secret: %s\\n\" % e)","title":"Example"},{"location":"#parameters_76","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] body V1DeleteOptions [optional]","title":"Parameters"},{"location":"#return-type_76","text":"V1Status","title":"Return type"},{"location":"#authorization_76","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_76","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_76","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#delete_collection_namespaced_service_account","text":"V1Status delete_collection_namespaced_service_account(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) delete collection of ServiceAccount","title":"delete_collection_namespaced_service_account"},{"location":"#example_77","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_collection_namespaced_service_account(namespace, pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_collection_namespaced_service_account: %s\\n\" % e)","title":"Example"},{"location":"#parameters_77","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] body V1DeleteOptions [optional]","title":"Parameters"},{"location":"#return-type_77","text":"V1Status","title":"Return type"},{"location":"#authorization_77","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_77","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_77","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#delete_collection_node","text":"V1Status delete_collection_node(pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) delete collection of Node","title":"delete_collection_node"},{"location":"#example_78","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_collection_node(pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_collection_node: %s\\n\" % e)","title":"Example"},{"location":"#parameters_78","text":"Name Type Description Notes pretty str If 'true', then the output is pretty printed. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] body V1DeleteOptions [optional]","title":"Parameters"},{"location":"#return-type_78","text":"V1Status","title":"Return type"},{"location":"#authorization_78","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_78","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_78","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#delete_collection_persistent_volume","text":"V1Status delete_collection_persistent_volume(pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) delete collection of PersistentVolume","title":"delete_collection_persistent_volume"},{"location":"#example_79","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_collection_persistent_volume(pretty=pretty, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, timeout_seconds=timeout_seconds, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_collection_persistent_volume: %s\\n\" % e)","title":"Example"},{"location":"#parameters_79","text":"Name Type Description Notes pretty str If 'true', then the output is pretty printed. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] body V1DeleteOptions [optional]","title":"Parameters"},{"location":"#return-type_79","text":"V1Status","title":"Return type"},{"location":"#authorization_79","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_79","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_79","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#delete_namespace","text":"V1Status delete_namespace(name, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) delete a Namespace","title":"delete_namespace"},{"location":"#example_80","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Namespace pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_namespace(name, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_namespace: %s\\n\" % e)","title":"Example"},{"location":"#parameters_80","text":"Name Type Description Notes name str name of the Namespace pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] body V1DeleteOptions [optional]","title":"Parameters"},{"location":"#return-type_80","text":"V1Status","title":"Return type"},{"location":"#authorization_80","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_80","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_80","text":"Status code Description Response headers 200 OK - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#delete_namespaced_config_map","text":"V1Status delete_namespaced_config_map(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) delete a ConfigMap","title":"delete_namespaced_config_map"},{"location":"#example_81","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ConfigMap namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_namespaced_config_map(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_namespaced_config_map: %s\\n\" % e)","title":"Example"},{"location":"#parameters_81","text":"Name Type Description Notes name str name of the ConfigMap namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] body V1DeleteOptions [optional]","title":"Parameters"},{"location":"#return-type_81","text":"V1Status","title":"Return type"},{"location":"#authorization_81","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_81","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_81","text":"Status code Description Response headers 200 OK - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#delete_namespaced_endpoints","text":"V1Status delete_namespaced_endpoints(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) delete Endpoints","title":"delete_namespaced_endpoints"},{"location":"#example_82","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Endpoints namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_namespaced_endpoints(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_namespaced_endpoints: %s\\n\" % e)","title":"Example"},{"location":"#parameters_82","text":"Name Type Description Notes name str name of the Endpoints namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] body V1DeleteOptions [optional]","title":"Parameters"},{"location":"#return-type_82","text":"V1Status","title":"Return type"},{"location":"#authorization_82","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_82","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_82","text":"Status code Description Response headers 200 OK - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#delete_namespaced_event","text":"V1Status delete_namespaced_event(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) delete an Event","title":"delete_namespaced_event"},{"location":"#example_83","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Event namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_namespaced_event(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_namespaced_event: %s\\n\" % e)","title":"Example"},{"location":"#parameters_83","text":"Name Type Description Notes name str name of the Event namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] body V1DeleteOptions [optional]","title":"Parameters"},{"location":"#return-type_83","text":"V1Status","title":"Return type"},{"location":"#authorization_83","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_83","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_83","text":"Status code Description Response headers 200 OK - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#delete_namespaced_limit_range","text":"V1Status delete_namespaced_limit_range(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) delete a LimitRange","title":"delete_namespaced_limit_range"},{"location":"#example_84","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the LimitRange namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_namespaced_limit_range(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_namespaced_limit_range: %s\\n\" % e)","title":"Example"},{"location":"#parameters_84","text":"Name Type Description Notes name str name of the LimitRange namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] body V1DeleteOptions [optional]","title":"Parameters"},{"location":"#return-type_84","text":"V1Status","title":"Return type"},{"location":"#authorization_84","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_84","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_84","text":"Status code Description Response headers 200 OK - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#delete_namespaced_persistent_volume_claim","text":"V1Status delete_namespaced_persistent_volume_claim(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) delete a PersistentVolumeClaim","title":"delete_namespaced_persistent_volume_claim"},{"location":"#example_85","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PersistentVolumeClaim namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_namespaced_persistent_volume_claim(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_namespaced_persistent_volume_claim: %s\\n\" % e)","title":"Example"},{"location":"#parameters_85","text":"Name Type Description Notes name str name of the PersistentVolumeClaim namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] body V1DeleteOptions [optional]","title":"Parameters"},{"location":"#return-type_85","text":"V1Status","title":"Return type"},{"location":"#authorization_85","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_85","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_85","text":"Status code Description Response headers 200 OK - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#delete_namespaced_pod","text":"V1Status delete_namespaced_pod(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) delete a Pod","title":"delete_namespaced_pod"},{"location":"#example_86","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Pod namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_namespaced_pod(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_namespaced_pod: %s\\n\" % e)","title":"Example"},{"location":"#parameters_86","text":"Name Type Description Notes name str name of the Pod namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] body V1DeleteOptions [optional]","title":"Parameters"},{"location":"#return-type_86","text":"V1Status","title":"Return type"},{"location":"#authorization_86","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_86","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_86","text":"Status code Description Response headers 200 OK - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#delete_namespaced_pod_template","text":"V1Status delete_namespaced_pod_template(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) delete a PodTemplate","title":"delete_namespaced_pod_template"},{"location":"#example_87","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodTemplate namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_namespaced_pod_template(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_namespaced_pod_template: %s\\n\" % e)","title":"Example"},{"location":"#parameters_87","text":"Name Type Description Notes name str name of the PodTemplate namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] body V1DeleteOptions [optional]","title":"Parameters"},{"location":"#return-type_87","text":"V1Status","title":"Return type"},{"location":"#authorization_87","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_87","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_87","text":"Status code Description Response headers 200 OK - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#delete_namespaced_replication_controller","text":"V1Status delete_namespaced_replication_controller(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) delete a ReplicationController","title":"delete_namespaced_replication_controller"},{"location":"#example_88","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ReplicationController namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_namespaced_replication_controller(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_namespaced_replication_controller: %s\\n\" % e)","title":"Example"},{"location":"#parameters_88","text":"Name Type Description Notes name str name of the ReplicationController namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] body V1DeleteOptions [optional]","title":"Parameters"},{"location":"#return-type_88","text":"V1Status","title":"Return type"},{"location":"#authorization_88","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_88","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_88","text":"Status code Description Response headers 200 OK - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#delete_namespaced_resource_quota","text":"V1Status delete_namespaced_resource_quota(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) delete a ResourceQuota","title":"delete_namespaced_resource_quota"},{"location":"#example_89","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ResourceQuota namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_namespaced_resource_quota(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_namespaced_resource_quota: %s\\n\" % e)","title":"Example"},{"location":"#parameters_89","text":"Name Type Description Notes name str name of the ResourceQuota namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] body V1DeleteOptions [optional]","title":"Parameters"},{"location":"#return-type_89","text":"V1Status","title":"Return type"},{"location":"#authorization_89","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_89","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_89","text":"Status code Description Response headers 200 OK - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#delete_namespaced_secret","text":"V1Status delete_namespaced_secret(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) delete a Secret","title":"delete_namespaced_secret"},{"location":"#example_90","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Secret namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_namespaced_secret(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_namespaced_secret: %s\\n\" % e)","title":"Example"},{"location":"#parameters_90","text":"Name Type Description Notes name str name of the Secret namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] body V1DeleteOptions [optional]","title":"Parameters"},{"location":"#return-type_90","text":"V1Status","title":"Return type"},{"location":"#authorization_90","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_90","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_90","text":"Status code Description Response headers 200 OK - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#delete_namespaced_service","text":"V1Status delete_namespaced_service(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) delete a Service","title":"delete_namespaced_service"},{"location":"#example_91","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Service namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_namespaced_service(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_namespaced_service: %s\\n\" % e)","title":"Example"},{"location":"#parameters_91","text":"Name Type Description Notes name str name of the Service namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] body V1DeleteOptions [optional]","title":"Parameters"},{"location":"#return-type_91","text":"V1Status","title":"Return type"},{"location":"#authorization_91","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_91","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_91","text":"Status code Description Response headers 200 OK - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#delete_namespaced_service_account","text":"V1Status delete_namespaced_service_account(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) delete a ServiceAccount","title":"delete_namespaced_service_account"},{"location":"#example_92","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceAccount namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_namespaced_service_account(name, namespace, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_namespaced_service_account: %s\\n\" % e)","title":"Example"},{"location":"#parameters_92","text":"Name Type Description Notes name str name of the ServiceAccount namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] body V1DeleteOptions [optional]","title":"Parameters"},{"location":"#return-type_92","text":"V1Status","title":"Return type"},{"location":"#authorization_92","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_92","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_92","text":"Status code Description Response headers 200 OK - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#delete_node","text":"V1Status delete_node(name, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) delete a Node","title":"delete_node"},{"location":"#example_93","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Node pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_node(name, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_node: %s\\n\" % e)","title":"Example"},{"location":"#parameters_93","text":"Name Type Description Notes name str name of the Node pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] body V1DeleteOptions [optional]","title":"Parameters"},{"location":"#return-type_93","text":"V1Status","title":"Return type"},{"location":"#authorization_93","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_93","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_93","text":"Status code Description Response headers 200 OK - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#delete_persistent_volume","text":"V1Status delete_persistent_volume(name, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) delete a PersistentVolume","title":"delete_persistent_volume"},{"location":"#example_94","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PersistentVolume pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) grace_period_seconds = 56 # int | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional) orphan_dependents = True # bool | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional) propagation_policy = 'propagation_policy_example' # str | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. (optional) body = kubernetes.client.V1DeleteOptions() # V1DeleteOptions | (optional) try: api_response = api_instance.delete_persistent_volume(name, pretty=pretty, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, body=body) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->delete_persistent_volume: %s\\n\" % e)","title":"Example"},{"location":"#parameters_94","text":"Name Type Description Notes name str name of the PersistentVolume pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] grace_period_seconds int The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. [optional] orphan_dependents bool Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \\\"orphan\\\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both. [optional] propagation_policy str Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground. [optional] body V1DeleteOptions [optional]","title":"Parameters"},{"location":"#return-type_94","text":"V1Status","title":"Return type"},{"location":"#authorization_94","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_94","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_94","text":"Status code Description Response headers 200 OK - 202 Accepted - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#get_api_resources","text":"V1APIResourceList get_api_resources() get available resources","title":"get_api_resources"},{"location":"#example_95","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) try: api_response = api_instance.get_api_resources() pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->get_api_resources: %s\\n\" % e)","title":"Example"},{"location":"#parameters_95","text":"This endpoint does not need any parameter.","title":"Parameters"},{"location":"#return-type_95","text":"V1APIResourceList","title":"Return type"},{"location":"#authorization_95","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_95","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_95","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#list_component_status","text":"V1ComponentStatusList list_component_status(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list objects of kind ComponentStatus","title":"list_component_status"},{"location":"#example_96","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_component_status(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_component_status: %s\\n\" % e)","title":"Example"},{"location":"#parameters_96","text":"Name Type Description Notes allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] pretty str If 'true', then the output is pretty printed. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional]","title":"Parameters"},{"location":"#return-type_96","text":"V1ComponentStatusList","title":"Return type"},{"location":"#authorization_96","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_96","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch","title":"HTTP request headers"},{"location":"#http-response-details_96","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#list_config_map_for_all_namespaces","text":"V1ConfigMapList list_config_map_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind ConfigMap","title":"list_config_map_for_all_namespaces"},{"location":"#example_97","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_config_map_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_config_map_for_all_namespaces: %s\\n\" % e)","title":"Example"},{"location":"#parameters_97","text":"Name Type Description Notes allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] pretty str If 'true', then the output is pretty printed. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional]","title":"Parameters"},{"location":"#return-type_97","text":"V1ConfigMapList","title":"Return type"},{"location":"#authorization_97","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_97","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch","title":"HTTP request headers"},{"location":"#http-response-details_97","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#list_endpoints_for_all_namespaces","text":"V1EndpointsList list_endpoints_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind Endpoints","title":"list_endpoints_for_all_namespaces"},{"location":"#example_98","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_endpoints_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_endpoints_for_all_namespaces: %s\\n\" % e)","title":"Example"},{"location":"#parameters_98","text":"Name Type Description Notes allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] pretty str If 'true', then the output is pretty printed. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional]","title":"Parameters"},{"location":"#return-type_98","text":"V1EndpointsList","title":"Return type"},{"location":"#authorization_98","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_98","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch","title":"HTTP request headers"},{"location":"#http-response-details_98","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#list_event_for_all_namespaces","text":"V1EventList list_event_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind Event","title":"list_event_for_all_namespaces"},{"location":"#example_99","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_event_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_event_for_all_namespaces: %s\\n\" % e)","title":"Example"},{"location":"#parameters_99","text":"Name Type Description Notes allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] pretty str If 'true', then the output is pretty printed. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional]","title":"Parameters"},{"location":"#return-type_99","text":"V1EventList","title":"Return type"},{"location":"#authorization_99","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_99","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch","title":"HTTP request headers"},{"location":"#http-response-details_99","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#list_limit_range_for_all_namespaces","text":"V1LimitRangeList list_limit_range_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind LimitRange","title":"list_limit_range_for_all_namespaces"},{"location":"#example_100","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_limit_range_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_limit_range_for_all_namespaces: %s\\n\" % e)","title":"Example"},{"location":"#parameters_100","text":"Name Type Description Notes allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] pretty str If 'true', then the output is pretty printed. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional]","title":"Parameters"},{"location":"#return-type_100","text":"V1LimitRangeList","title":"Return type"},{"location":"#authorization_100","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_100","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch","title":"HTTP request headers"},{"location":"#http-response-details_100","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#list_namespace","text":"V1NamespaceList list_namespace(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind Namespace","title":"list_namespace"},{"location":"#example_101","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_namespace(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_namespace: %s\\n\" % e)","title":"Example"},{"location":"#parameters_101","text":"Name Type Description Notes pretty str If 'true', then the output is pretty printed. [optional] allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional]","title":"Parameters"},{"location":"#return-type_101","text":"V1NamespaceList","title":"Return type"},{"location":"#authorization_101","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_101","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch","title":"HTTP request headers"},{"location":"#http-response-details_101","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#list_namespaced_config_map","text":"V1ConfigMapList list_namespaced_config_map(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind ConfigMap","title":"list_namespaced_config_map"},{"location":"#example_102","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_namespaced_config_map(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_namespaced_config_map: %s\\n\" % e)","title":"Example"},{"location":"#parameters_102","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional]","title":"Parameters"},{"location":"#return-type_102","text":"V1ConfigMapList","title":"Return type"},{"location":"#authorization_102","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_102","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch","title":"HTTP request headers"},{"location":"#http-response-details_102","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#list_namespaced_endpoints","text":"V1EndpointsList list_namespaced_endpoints(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind Endpoints","title":"list_namespaced_endpoints"},{"location":"#example_103","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_namespaced_endpoints(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_namespaced_endpoints: %s\\n\" % e)","title":"Example"},{"location":"#parameters_103","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional]","title":"Parameters"},{"location":"#return-type_103","text":"V1EndpointsList","title":"Return type"},{"location":"#authorization_103","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_103","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch","title":"HTTP request headers"},{"location":"#http-response-details_103","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#list_namespaced_event","text":"V1EventList list_namespaced_event(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind Event","title":"list_namespaced_event"},{"location":"#example_104","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_namespaced_event(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_namespaced_event: %s\\n\" % e)","title":"Example"},{"location":"#parameters_104","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional]","title":"Parameters"},{"location":"#return-type_104","text":"V1EventList","title":"Return type"},{"location":"#authorization_104","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_104","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch","title":"HTTP request headers"},{"location":"#http-response-details_104","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#list_namespaced_limit_range","text":"V1LimitRangeList list_namespaced_limit_range(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind LimitRange","title":"list_namespaced_limit_range"},{"location":"#example_105","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_namespaced_limit_range(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_namespaced_limit_range: %s\\n\" % e)","title":"Example"},{"location":"#parameters_105","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional]","title":"Parameters"},{"location":"#return-type_105","text":"V1LimitRangeList","title":"Return type"},{"location":"#authorization_105","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_105","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch","title":"HTTP request headers"},{"location":"#http-response-details_105","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#list_namespaced_persistent_volume_claim","text":"V1PersistentVolumeClaimList list_namespaced_persistent_volume_claim(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind PersistentVolumeClaim","title":"list_namespaced_persistent_volume_claim"},{"location":"#example_106","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_namespaced_persistent_volume_claim(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_namespaced_persistent_volume_claim: %s\\n\" % e)","title":"Example"},{"location":"#parameters_106","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional]","title":"Parameters"},{"location":"#return-type_106","text":"V1PersistentVolumeClaimList","title":"Return type"},{"location":"#authorization_106","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_106","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch","title":"HTTP request headers"},{"location":"#http-response-details_106","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#list_namespaced_pod","text":"V1PodList list_namespaced_pod(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind Pod","title":"list_namespaced_pod"},{"location":"#example_107","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_namespaced_pod(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_namespaced_pod: %s\\n\" % e)","title":"Example"},{"location":"#parameters_107","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional]","title":"Parameters"},{"location":"#return-type_107","text":"V1PodList","title":"Return type"},{"location":"#authorization_107","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_107","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch","title":"HTTP request headers"},{"location":"#http-response-details_107","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#list_namespaced_pod_template","text":"V1PodTemplateList list_namespaced_pod_template(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind PodTemplate","title":"list_namespaced_pod_template"},{"location":"#example_108","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_namespaced_pod_template(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_namespaced_pod_template: %s\\n\" % e)","title":"Example"},{"location":"#parameters_108","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional]","title":"Parameters"},{"location":"#return-type_108","text":"V1PodTemplateList","title":"Return type"},{"location":"#authorization_108","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_108","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch","title":"HTTP request headers"},{"location":"#http-response-details_108","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#list_namespaced_replication_controller","text":"V1ReplicationControllerList list_namespaced_replication_controller(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind ReplicationController","title":"list_namespaced_replication_controller"},{"location":"#example_109","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_namespaced_replication_controller(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_namespaced_replication_controller: %s\\n\" % e)","title":"Example"},{"location":"#parameters_109","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional]","title":"Parameters"},{"location":"#return-type_109","text":"V1ReplicationControllerList","title":"Return type"},{"location":"#authorization_109","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_109","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch","title":"HTTP request headers"},{"location":"#http-response-details_109","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#list_namespaced_resource_quota","text":"V1ResourceQuotaList list_namespaced_resource_quota(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind ResourceQuota","title":"list_namespaced_resource_quota"},{"location":"#example_110","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_namespaced_resource_quota(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_namespaced_resource_quota: %s\\n\" % e)","title":"Example"},{"location":"#parameters_110","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional]","title":"Parameters"},{"location":"#return-type_110","text":"V1ResourceQuotaList","title":"Return type"},{"location":"#authorization_110","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_110","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch","title":"HTTP request headers"},{"location":"#http-response-details_110","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#list_namespaced_secret","text":"V1SecretList list_namespaced_secret(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind Secret","title":"list_namespaced_secret"},{"location":"#example_111","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_namespaced_secret(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_namespaced_secret: %s\\n\" % e)","title":"Example"},{"location":"#parameters_111","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional]","title":"Parameters"},{"location":"#return-type_111","text":"V1SecretList","title":"Return type"},{"location":"#authorization_111","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_111","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch","title":"HTTP request headers"},{"location":"#http-response-details_111","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#list_namespaced_service","text":"V1ServiceList list_namespaced_service(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind Service","title":"list_namespaced_service"},{"location":"#example_112","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_namespaced_service(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_namespaced_service: %s\\n\" % e)","title":"Example"},{"location":"#parameters_112","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional]","title":"Parameters"},{"location":"#return-type_112","text":"V1ServiceList","title":"Return type"},{"location":"#authorization_112","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_112","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch","title":"HTTP request headers"},{"location":"#http-response-details_112","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#list_namespaced_service_account","text":"V1ServiceAccountList list_namespaced_service_account(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind ServiceAccount","title":"list_namespaced_service_account"},{"location":"#example_113","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_namespaced_service_account(namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_namespaced_service_account: %s\\n\" % e)","title":"Example"},{"location":"#parameters_113","text":"Name Type Description Notes namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional]","title":"Parameters"},{"location":"#return-type_113","text":"V1ServiceAccountList","title":"Return type"},{"location":"#authorization_113","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_113","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch","title":"HTTP request headers"},{"location":"#http-response-details_113","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#list_node","text":"V1NodeList list_node(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind Node","title":"list_node"},{"location":"#example_114","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_node(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_node: %s\\n\" % e)","title":"Example"},{"location":"#parameters_114","text":"Name Type Description Notes pretty str If 'true', then the output is pretty printed. [optional] allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional]","title":"Parameters"},{"location":"#return-type_114","text":"V1NodeList","title":"Return type"},{"location":"#authorization_114","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_114","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch","title":"HTTP request headers"},{"location":"#http-response-details_114","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#list_persistent_volume","text":"V1PersistentVolumeList list_persistent_volume(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind PersistentVolume","title":"list_persistent_volume"},{"location":"#example_115","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_persistent_volume(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_persistent_volume: %s\\n\" % e)","title":"Example"},{"location":"#parameters_115","text":"Name Type Description Notes pretty str If 'true', then the output is pretty printed. [optional] allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional]","title":"Parameters"},{"location":"#return-type_115","text":"V1PersistentVolumeList","title":"Return type"},{"location":"#authorization_115","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_115","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch","title":"HTTP request headers"},{"location":"#http-response-details_115","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#list_persistent_volume_claim_for_all_namespaces","text":"V1PersistentVolumeClaimList list_persistent_volume_claim_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind PersistentVolumeClaim","title":"list_persistent_volume_claim_for_all_namespaces"},{"location":"#example_116","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_persistent_volume_claim_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_persistent_volume_claim_for_all_namespaces: %s\\n\" % e)","title":"Example"},{"location":"#parameters_116","text":"Name Type Description Notes allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] pretty str If 'true', then the output is pretty printed. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional]","title":"Parameters"},{"location":"#return-type_116","text":"V1PersistentVolumeClaimList","title":"Return type"},{"location":"#authorization_116","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_116","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch","title":"HTTP request headers"},{"location":"#http-response-details_116","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#list_pod_for_all_namespaces","text":"V1PodList list_pod_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind Pod","title":"list_pod_for_all_namespaces"},{"location":"#example_117","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_pod_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_pod_for_all_namespaces: %s\\n\" % e)","title":"Example"},{"location":"#parameters_117","text":"Name Type Description Notes allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] pretty str If 'true', then the output is pretty printed. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional]","title":"Parameters"},{"location":"#return-type_117","text":"V1PodList","title":"Return type"},{"location":"#authorization_117","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_117","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch","title":"HTTP request headers"},{"location":"#http-response-details_117","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#list_pod_template_for_all_namespaces","text":"V1PodTemplateList list_pod_template_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind PodTemplate","title":"list_pod_template_for_all_namespaces"},{"location":"#example_118","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_pod_template_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_pod_template_for_all_namespaces: %s\\n\" % e)","title":"Example"},{"location":"#parameters_118","text":"Name Type Description Notes allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] pretty str If 'true', then the output is pretty printed. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional]","title":"Parameters"},{"location":"#return-type_118","text":"V1PodTemplateList","title":"Return type"},{"location":"#authorization_118","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_118","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch","title":"HTTP request headers"},{"location":"#http-response-details_118","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#list_replication_controller_for_all_namespaces","text":"V1ReplicationControllerList list_replication_controller_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind ReplicationController","title":"list_replication_controller_for_all_namespaces"},{"location":"#example_119","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_replication_controller_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_replication_controller_for_all_namespaces: %s\\n\" % e)","title":"Example"},{"location":"#parameters_119","text":"Name Type Description Notes allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] pretty str If 'true', then the output is pretty printed. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional]","title":"Parameters"},{"location":"#return-type_119","text":"V1ReplicationControllerList","title":"Return type"},{"location":"#authorization_119","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_119","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch","title":"HTTP request headers"},{"location":"#http-response-details_119","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#list_resource_quota_for_all_namespaces","text":"V1ResourceQuotaList list_resource_quota_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind ResourceQuota","title":"list_resource_quota_for_all_namespaces"},{"location":"#example_120","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_resource_quota_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_resource_quota_for_all_namespaces: %s\\n\" % e)","title":"Example"},{"location":"#parameters_120","text":"Name Type Description Notes allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] pretty str If 'true', then the output is pretty printed. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional]","title":"Parameters"},{"location":"#return-type_120","text":"V1ResourceQuotaList","title":"Return type"},{"location":"#authorization_120","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_120","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch","title":"HTTP request headers"},{"location":"#http-response-details_120","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#list_secret_for_all_namespaces","text":"V1SecretList list_secret_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind Secret","title":"list_secret_for_all_namespaces"},{"location":"#example_121","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_secret_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_secret_for_all_namespaces: %s\\n\" % e)","title":"Example"},{"location":"#parameters_121","text":"Name Type Description Notes allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] pretty str If 'true', then the output is pretty printed. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional]","title":"Parameters"},{"location":"#return-type_121","text":"V1SecretList","title":"Return type"},{"location":"#authorization_121","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_121","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch","title":"HTTP request headers"},{"location":"#http-response-details_121","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#list_service_account_for_all_namespaces","text":"V1ServiceAccountList list_service_account_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind ServiceAccount","title":"list_service_account_for_all_namespaces"},{"location":"#example_122","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_service_account_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_service_account_for_all_namespaces: %s\\n\" % e)","title":"Example"},{"location":"#parameters_122","text":"Name Type Description Notes allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] pretty str If 'true', then the output is pretty printed. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional]","title":"Parameters"},{"location":"#return-type_122","text":"V1ServiceAccountList","title":"Return type"},{"location":"#authorization_122","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_122","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch","title":"HTTP request headers"},{"location":"#http-response-details_122","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#list_service_for_all_namespaces","text":"V1ServiceList list_service_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) list or watch objects of kind Service","title":"list_service_for_all_namespaces"},{"location":"#example_123","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) allow_watch_bookmarks = True # bool | allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. (optional) _continue = '_continue_example' # str | The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional) field_selector = 'field_selector_example' # str | A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional) label_selector = 'label_selector_example' # str | A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional) limit = 56 # int | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) resource_version = 'resource_version_example' # str | When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional) timeout_seconds = 56 # int | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional) watch = True # bool | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional) try: api_response = api_instance.list_service_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, timeout_seconds=timeout_seconds, watch=watch) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->list_service_for_all_namespaces: %s\\n\" % e)","title":"Example"},{"location":"#parameters_123","text":"Name Type Description Notes allow_watch_bookmarks bool allowWatchBookmarks requests watch events with type \\\"BOOKMARK\\\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored. [optional] _continue str The continue option should be set when retrieving more results from the server. Since this value is server defined, kubernetes.clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the kubernetes.client needs a consistent list, it must restart their list without the continue field. Otherwise, the kubernetes.client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \\\"next key\\\". This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. [optional] field_selector str A selector to restrict the list of returned objects by their fields. Defaults to everything. [optional] label_selector str A selector to restrict the list of returned objects by their labels. Defaults to everything. [optional] limit int limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and kubernetes.clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, kubernetes.clients may assume that no more results are available. This field is not supported if watch is true. The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a kubernetes.client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. [optional] pretty str If 'true', then the output is pretty printed. [optional] resource_version str When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. [optional] timeout_seconds int Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. [optional] watch bool Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. [optional]","title":"Parameters"},{"location":"#return-type_123","text":"V1ServiceList","title":"Return type"},{"location":"#authorization_123","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_123","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch","title":"HTTP request headers"},{"location":"#http-response-details_123","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#patch_namespace","text":"V1Namespace patch_namespace(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update the specified Namespace","title":"patch_namespace"},{"location":"#example_124","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Namespace body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespace(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespace: %s\\n\" % e)","title":"Example"},{"location":"#parameters_124","text":"Name Type Description Notes name str name of the Namespace body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional]","title":"Parameters"},{"location":"#return-type_124","text":"V1Namespace","title":"Return type"},{"location":"#authorization_124","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_124","text":"Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_124","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#patch_namespace_status","text":"V1Namespace patch_namespace_status(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update status of the specified Namespace","title":"patch_namespace_status"},{"location":"#example_125","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Namespace body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespace_status(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespace_status: %s\\n\" % e)","title":"Example"},{"location":"#parameters_125","text":"Name Type Description Notes name str name of the Namespace body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional]","title":"Parameters"},{"location":"#return-type_125","text":"V1Namespace","title":"Return type"},{"location":"#authorization_125","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_125","text":"Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_125","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#patch_namespaced_config_map","text":"V1ConfigMap patch_namespaced_config_map(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update the specified ConfigMap","title":"patch_namespaced_config_map"},{"location":"#example_126","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ConfigMap namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_config_map(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_config_map: %s\\n\" % e)","title":"Example"},{"location":"#parameters_126","text":"Name Type Description Notes name str name of the ConfigMap namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional]","title":"Parameters"},{"location":"#return-type_126","text":"V1ConfigMap","title":"Return type"},{"location":"#authorization_126","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_126","text":"Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_126","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#patch_namespaced_endpoints","text":"V1Endpoints patch_namespaced_endpoints(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update the specified Endpoints","title":"patch_namespaced_endpoints"},{"location":"#example_127","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Endpoints namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_endpoints(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_endpoints: %s\\n\" % e)","title":"Example"},{"location":"#parameters_127","text":"Name Type Description Notes name str name of the Endpoints namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional]","title":"Parameters"},{"location":"#return-type_127","text":"V1Endpoints","title":"Return type"},{"location":"#authorization_127","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_127","text":"Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_127","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#patch_namespaced_event","text":"V1Event patch_namespaced_event(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update the specified Event","title":"patch_namespaced_event"},{"location":"#example_128","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Event namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_event(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_event: %s\\n\" % e)","title":"Example"},{"location":"#parameters_128","text":"Name Type Description Notes name str name of the Event namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional]","title":"Parameters"},{"location":"#return-type_128","text":"V1Event","title":"Return type"},{"location":"#authorization_128","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_128","text":"Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_128","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#patch_namespaced_limit_range","text":"V1LimitRange patch_namespaced_limit_range(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update the specified LimitRange","title":"patch_namespaced_limit_range"},{"location":"#example_129","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the LimitRange namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_limit_range(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_limit_range: %s\\n\" % e)","title":"Example"},{"location":"#parameters_129","text":"Name Type Description Notes name str name of the LimitRange namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional]","title":"Parameters"},{"location":"#return-type_129","text":"V1LimitRange","title":"Return type"},{"location":"#authorization_129","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_129","text":"Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_129","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#patch_namespaced_persistent_volume_claim","text":"V1PersistentVolumeClaim patch_namespaced_persistent_volume_claim(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update the specified PersistentVolumeClaim","title":"patch_namespaced_persistent_volume_claim"},{"location":"#example_130","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PersistentVolumeClaim namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_persistent_volume_claim(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_persistent_volume_claim: %s\\n\" % e)","title":"Example"},{"location":"#parameters_130","text":"Name Type Description Notes name str name of the PersistentVolumeClaim namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional]","title":"Parameters"},{"location":"#return-type_130","text":"V1PersistentVolumeClaim","title":"Return type"},{"location":"#authorization_130","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_130","text":"Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_130","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#patch_namespaced_persistent_volume_claim_status","text":"V1PersistentVolumeClaim patch_namespaced_persistent_volume_claim_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update status of the specified PersistentVolumeClaim","title":"patch_namespaced_persistent_volume_claim_status"},{"location":"#example_131","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PersistentVolumeClaim namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_persistent_volume_claim_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_persistent_volume_claim_status: %s\\n\" % e)","title":"Example"},{"location":"#parameters_131","text":"Name Type Description Notes name str name of the PersistentVolumeClaim namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional]","title":"Parameters"},{"location":"#return-type_131","text":"V1PersistentVolumeClaim","title":"Return type"},{"location":"#authorization_131","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_131","text":"Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_131","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#patch_namespaced_pod","text":"V1Pod patch_namespaced_pod(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update the specified Pod","title":"patch_namespaced_pod"},{"location":"#example_132","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Pod namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_pod(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_pod: %s\\n\" % e)","title":"Example"},{"location":"#parameters_132","text":"Name Type Description Notes name str name of the Pod namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional]","title":"Parameters"},{"location":"#return-type_132","text":"V1Pod","title":"Return type"},{"location":"#authorization_132","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_132","text":"Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_132","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#patch_namespaced_pod_status","text":"V1Pod patch_namespaced_pod_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update status of the specified Pod","title":"patch_namespaced_pod_status"},{"location":"#example_133","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Pod namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_pod_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_pod_status: %s\\n\" % e)","title":"Example"},{"location":"#parameters_133","text":"Name Type Description Notes name str name of the Pod namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional]","title":"Parameters"},{"location":"#return-type_133","text":"V1Pod","title":"Return type"},{"location":"#authorization_133","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_133","text":"Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_133","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#patch_namespaced_pod_template","text":"V1PodTemplate patch_namespaced_pod_template(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update the specified PodTemplate","title":"patch_namespaced_pod_template"},{"location":"#example_134","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodTemplate namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_pod_template(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_pod_template: %s\\n\" % e)","title":"Example"},{"location":"#parameters_134","text":"Name Type Description Notes name str name of the PodTemplate namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional]","title":"Parameters"},{"location":"#return-type_134","text":"V1PodTemplate","title":"Return type"},{"location":"#authorization_134","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_134","text":"Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_134","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#patch_namespaced_replication_controller","text":"V1ReplicationController patch_namespaced_replication_controller(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update the specified ReplicationController","title":"patch_namespaced_replication_controller"},{"location":"#example_135","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ReplicationController namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_replication_controller(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_replication_controller: %s\\n\" % e)","title":"Example"},{"location":"#parameters_135","text":"Name Type Description Notes name str name of the ReplicationController namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional]","title":"Parameters"},{"location":"#return-type_135","text":"V1ReplicationController","title":"Return type"},{"location":"#authorization_135","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_135","text":"Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_135","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#patch_namespaced_replication_controller_scale","text":"V1Scale patch_namespaced_replication_controller_scale(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update scale of the specified ReplicationController","title":"patch_namespaced_replication_controller_scale"},{"location":"#example_136","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Scale namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_replication_controller_scale(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_replication_controller_scale: %s\\n\" % e)","title":"Example"},{"location":"#parameters_136","text":"Name Type Description Notes name str name of the Scale namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional]","title":"Parameters"},{"location":"#return-type_136","text":"V1Scale","title":"Return type"},{"location":"#authorization_136","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_136","text":"Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_136","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#patch_namespaced_replication_controller_status","text":"V1ReplicationController patch_namespaced_replication_controller_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update status of the specified ReplicationController","title":"patch_namespaced_replication_controller_status"},{"location":"#example_137","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ReplicationController namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_replication_controller_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_replication_controller_status: %s\\n\" % e)","title":"Example"},{"location":"#parameters_137","text":"Name Type Description Notes name str name of the ReplicationController namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional]","title":"Parameters"},{"location":"#return-type_137","text":"V1ReplicationController","title":"Return type"},{"location":"#authorization_137","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_137","text":"Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_137","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#patch_namespaced_resource_quota","text":"V1ResourceQuota patch_namespaced_resource_quota(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update the specified ResourceQuota","title":"patch_namespaced_resource_quota"},{"location":"#example_138","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ResourceQuota namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_resource_quota(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_resource_quota: %s\\n\" % e)","title":"Example"},{"location":"#parameters_138","text":"Name Type Description Notes name str name of the ResourceQuota namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional]","title":"Parameters"},{"location":"#return-type_138","text":"V1ResourceQuota","title":"Return type"},{"location":"#authorization_138","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_138","text":"Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_138","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#patch_namespaced_resource_quota_status","text":"V1ResourceQuota patch_namespaced_resource_quota_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update status of the specified ResourceQuota","title":"patch_namespaced_resource_quota_status"},{"location":"#example_139","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ResourceQuota namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_resource_quota_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_resource_quota_status: %s\\n\" % e)","title":"Example"},{"location":"#parameters_139","text":"Name Type Description Notes name str name of the ResourceQuota namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional]","title":"Parameters"},{"location":"#return-type_139","text":"V1ResourceQuota","title":"Return type"},{"location":"#authorization_139","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_139","text":"Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_139","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#patch_namespaced_secret","text":"V1Secret patch_namespaced_secret(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update the specified Secret","title":"patch_namespaced_secret"},{"location":"#example_140","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Secret namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_secret(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_secret: %s\\n\" % e)","title":"Example"},{"location":"#parameters_140","text":"Name Type Description Notes name str name of the Secret namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional]","title":"Parameters"},{"location":"#return-type_140","text":"V1Secret","title":"Return type"},{"location":"#authorization_140","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_140","text":"Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_140","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#patch_namespaced_service","text":"V1Service patch_namespaced_service(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update the specified Service","title":"patch_namespaced_service"},{"location":"#example_141","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Service namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_service(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_service: %s\\n\" % e)","title":"Example"},{"location":"#parameters_141","text":"Name Type Description Notes name str name of the Service namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional]","title":"Parameters"},{"location":"#return-type_141","text":"V1Service","title":"Return type"},{"location":"#authorization_141","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_141","text":"Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_141","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#patch_namespaced_service_account","text":"V1ServiceAccount patch_namespaced_service_account(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update the specified ServiceAccount","title":"patch_namespaced_service_account"},{"location":"#example_142","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceAccount namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_service_account(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_service_account: %s\\n\" % e)","title":"Example"},{"location":"#parameters_142","text":"Name Type Description Notes name str name of the ServiceAccount namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional]","title":"Parameters"},{"location":"#return-type_142","text":"V1ServiceAccount","title":"Return type"},{"location":"#authorization_142","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_142","text":"Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_142","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#patch_namespaced_service_status","text":"V1Service patch_namespaced_service_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update status of the specified Service","title":"patch_namespaced_service_status"},{"location":"#example_143","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Service namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_namespaced_service_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_namespaced_service_status: %s\\n\" % e)","title":"Example"},{"location":"#parameters_143","text":"Name Type Description Notes name str name of the Service namespace str object name and auth scope, such as for teams and projects body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional]","title":"Parameters"},{"location":"#return-type_143","text":"V1Service","title":"Return type"},{"location":"#authorization_143","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_143","text":"Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_143","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#patch_node","text":"V1Node patch_node(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update the specified Node","title":"patch_node"},{"location":"#example_144","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Node body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_node(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_node: %s\\n\" % e)","title":"Example"},{"location":"#parameters_144","text":"Name Type Description Notes name str name of the Node body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional]","title":"Parameters"},{"location":"#return-type_144","text":"V1Node","title":"Return type"},{"location":"#authorization_144","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_144","text":"Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_144","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#patch_node_status","text":"V1Node patch_node_status(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update status of the specified Node","title":"patch_node_status"},{"location":"#example_145","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Node body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_node_status(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_node_status: %s\\n\" % e)","title":"Example"},{"location":"#parameters_145","text":"Name Type Description Notes name str name of the Node body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional]","title":"Parameters"},{"location":"#return-type_145","text":"V1Node","title":"Return type"},{"location":"#authorization_145","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_145","text":"Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_145","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#patch_persistent_volume","text":"V1PersistentVolume patch_persistent_volume(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update the specified PersistentVolume","title":"patch_persistent_volume"},{"location":"#example_146","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PersistentVolume body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_persistent_volume(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_persistent_volume: %s\\n\" % e)","title":"Example"},{"location":"#parameters_146","text":"Name Type Description Notes name str name of the PersistentVolume body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional]","title":"Parameters"},{"location":"#return-type_146","text":"V1PersistentVolume","title":"Return type"},{"location":"#authorization_146","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_146","text":"Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_146","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#patch_persistent_volume_status","text":"V1PersistentVolume patch_persistent_volume_status(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) partially update status of the specified PersistentVolume","title":"patch_persistent_volume_status"},{"location":"#example_147","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PersistentVolume body = None # object | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional) force = True # bool | Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional) try: api_response = api_instance.patch_persistent_volume_status(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, force=force) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->patch_persistent_volume_status: %s\\n\" % e)","title":"Example"},{"location":"#parameters_147","text":"Name Type Description Notes name str name of the PersistentVolume body object pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). [optional] force bool Force is going to \\\"force\\\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. [optional]","title":"Parameters"},{"location":"#return-type_147","text":"V1PersistentVolume","title":"Return type"},{"location":"#authorization_147","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_147","text":"Content-Type : application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_147","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#read_component_status","text":"V1ComponentStatus read_component_status(name, pretty=pretty) read the specified ComponentStatus","title":"read_component_status"},{"location":"#example_148","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ComponentStatus pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) try: api_response = api_instance.read_component_status(name, pretty=pretty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_component_status: %s\\n\" % e)","title":"Example"},{"location":"#parameters_148","text":"Name Type Description Notes name str name of the ComponentStatus pretty str If 'true', then the output is pretty printed. [optional]","title":"Parameters"},{"location":"#return-type_148","text":"V1ComponentStatus","title":"Return type"},{"location":"#authorization_148","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_148","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_148","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#read_namespace","text":"V1Namespace read_namespace(name, pretty=pretty, exact=exact, export=export) read the specified Namespace","title":"read_namespace"},{"location":"#example_149","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Namespace pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) exact = True # bool | Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. (optional) export = True # bool | Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional) try: api_response = api_instance.read_namespace(name, pretty=pretty, exact=exact, export=export) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespace: %s\\n\" % e)","title":"Example"},{"location":"#parameters_149","text":"Name Type Description Notes name str name of the Namespace pretty str If 'true', then the output is pretty printed. [optional] exact bool Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. [optional] export bool Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. [optional]","title":"Parameters"},{"location":"#return-type_149","text":"V1Namespace","title":"Return type"},{"location":"#authorization_149","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_149","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_149","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#read_namespace_status","text":"V1Namespace read_namespace_status(name, pretty=pretty) read status of the specified Namespace","title":"read_namespace_status"},{"location":"#example_150","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Namespace pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) try: api_response = api_instance.read_namespace_status(name, pretty=pretty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespace_status: %s\\n\" % e)","title":"Example"},{"location":"#parameters_150","text":"Name Type Description Notes name str name of the Namespace pretty str If 'true', then the output is pretty printed. [optional]","title":"Parameters"},{"location":"#return-type_150","text":"V1Namespace","title":"Return type"},{"location":"#authorization_150","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_150","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_150","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#read_namespaced_config_map","text":"V1ConfigMap read_namespaced_config_map(name, namespace, pretty=pretty, exact=exact, export=export) read the specified ConfigMap","title":"read_namespaced_config_map"},{"location":"#example_151","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ConfigMap namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) exact = True # bool | Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. (optional) export = True # bool | Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional) try: api_response = api_instance.read_namespaced_config_map(name, namespace, pretty=pretty, exact=exact, export=export) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_config_map: %s\\n\" % e)","title":"Example"},{"location":"#parameters_151","text":"Name Type Description Notes name str name of the ConfigMap namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] exact bool Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. [optional] export bool Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. [optional]","title":"Parameters"},{"location":"#return-type_151","text":"V1ConfigMap","title":"Return type"},{"location":"#authorization_151","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_151","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_151","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#read_namespaced_endpoints","text":"V1Endpoints read_namespaced_endpoints(name, namespace, pretty=pretty, exact=exact, export=export) read the specified Endpoints","title":"read_namespaced_endpoints"},{"location":"#example_152","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Endpoints namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) exact = True # bool | Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. (optional) export = True # bool | Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional) try: api_response = api_instance.read_namespaced_endpoints(name, namespace, pretty=pretty, exact=exact, export=export) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_endpoints: %s\\n\" % e)","title":"Example"},{"location":"#parameters_152","text":"Name Type Description Notes name str name of the Endpoints namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] exact bool Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. [optional] export bool Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. [optional]","title":"Parameters"},{"location":"#return-type_152","text":"V1Endpoints","title":"Return type"},{"location":"#authorization_152","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_152","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_152","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#read_namespaced_event","text":"V1Event read_namespaced_event(name, namespace, pretty=pretty, exact=exact, export=export) read the specified Event","title":"read_namespaced_event"},{"location":"#example_153","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Event namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) exact = True # bool | Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. (optional) export = True # bool | Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional) try: api_response = api_instance.read_namespaced_event(name, namespace, pretty=pretty, exact=exact, export=export) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_event: %s\\n\" % e)","title":"Example"},{"location":"#parameters_153","text":"Name Type Description Notes name str name of the Event namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] exact bool Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. [optional] export bool Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. [optional]","title":"Parameters"},{"location":"#return-type_153","text":"V1Event","title":"Return type"},{"location":"#authorization_153","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_153","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_153","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#read_namespaced_limit_range","text":"V1LimitRange read_namespaced_limit_range(name, namespace, pretty=pretty, exact=exact, export=export) read the specified LimitRange","title":"read_namespaced_limit_range"},{"location":"#example_154","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the LimitRange namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) exact = True # bool | Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. (optional) export = True # bool | Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional) try: api_response = api_instance.read_namespaced_limit_range(name, namespace, pretty=pretty, exact=exact, export=export) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_limit_range: %s\\n\" % e)","title":"Example"},{"location":"#parameters_154","text":"Name Type Description Notes name str name of the LimitRange namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] exact bool Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. [optional] export bool Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. [optional]","title":"Parameters"},{"location":"#return-type_154","text":"V1LimitRange","title":"Return type"},{"location":"#authorization_154","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_154","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_154","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#read_namespaced_persistent_volume_claim","text":"V1PersistentVolumeClaim read_namespaced_persistent_volume_claim(name, namespace, pretty=pretty, exact=exact, export=export) read the specified PersistentVolumeClaim","title":"read_namespaced_persistent_volume_claim"},{"location":"#example_155","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PersistentVolumeClaim namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) exact = True # bool | Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. (optional) export = True # bool | Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional) try: api_response = api_instance.read_namespaced_persistent_volume_claim(name, namespace, pretty=pretty, exact=exact, export=export) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_persistent_volume_claim: %s\\n\" % e)","title":"Example"},{"location":"#parameters_155","text":"Name Type Description Notes name str name of the PersistentVolumeClaim namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] exact bool Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. [optional] export bool Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. [optional]","title":"Parameters"},{"location":"#return-type_155","text":"V1PersistentVolumeClaim","title":"Return type"},{"location":"#authorization_155","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_155","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_155","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#read_namespaced_persistent_volume_claim_status","text":"V1PersistentVolumeClaim read_namespaced_persistent_volume_claim_status(name, namespace, pretty=pretty) read status of the specified PersistentVolumeClaim","title":"read_namespaced_persistent_volume_claim_status"},{"location":"#example_156","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PersistentVolumeClaim namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) try: api_response = api_instance.read_namespaced_persistent_volume_claim_status(name, namespace, pretty=pretty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_persistent_volume_claim_status: %s\\n\" % e)","title":"Example"},{"location":"#parameters_156","text":"Name Type Description Notes name str name of the PersistentVolumeClaim namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional]","title":"Parameters"},{"location":"#return-type_156","text":"V1PersistentVolumeClaim","title":"Return type"},{"location":"#authorization_156","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_156","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_156","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#read_namespaced_pod","text":"V1Pod read_namespaced_pod(name, namespace, pretty=pretty, exact=exact, export=export) read the specified Pod","title":"read_namespaced_pod"},{"location":"#example_157","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Pod namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) exact = True # bool | Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. (optional) export = True # bool | Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional) try: api_response = api_instance.read_namespaced_pod(name, namespace, pretty=pretty, exact=exact, export=export) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_pod: %s\\n\" % e)","title":"Example"},{"location":"#parameters_157","text":"Name Type Description Notes name str name of the Pod namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] exact bool Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. [optional] export bool Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. [optional]","title":"Parameters"},{"location":"#return-type_157","text":"V1Pod","title":"Return type"},{"location":"#authorization_157","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_157","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_157","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#read_namespaced_pod_log","text":"str read_namespaced_pod_log(name, namespace, container=container, follow=follow, insecure_skip_tls_verify_backend=insecure_skip_tls_verify_backend, limit_bytes=limit_bytes, pretty=pretty, previous=previous, since_seconds=since_seconds, tail_lines=tail_lines, timestamps=timestamps) read log of the specified Pod","title":"read_namespaced_pod_log"},{"location":"#example_158","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Pod namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects container = 'container_example' # str | The container for which to stream logs. Defaults to only container if there is one container in the pod. (optional) follow = True # bool | Follow the log stream of the pod. Defaults to false. (optional) insecure_skip_tls_verify_backend = True # bool | insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the serving certificate of the backend it is connecting to. This will make the HTTPS connection between the apiserver and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real kubelet. If the kubelet is configured to verify the apiserver's TLS credentials, it does not mean the connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept the actual log data coming from the real kubelet). (optional) limit_bytes = 56 # int | If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) previous = True # bool | Return previous terminated container logs. Defaults to false. (optional) since_seconds = 56 # int | A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified. (optional) tail_lines = 56 # int | If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime (optional) timestamps = True # bool | If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false. (optional) try: api_response = api_instance.read_namespaced_pod_log(name, namespace, container=container, follow=follow, insecure_skip_tls_verify_backend=insecure_skip_tls_verify_backend, limit_bytes=limit_bytes, pretty=pretty, previous=previous, since_seconds=since_seconds, tail_lines=tail_lines, timestamps=timestamps) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_pod_log: %s\\n\" % e)","title":"Example"},{"location":"#parameters_158","text":"Name Type Description Notes name str name of the Pod namespace str object name and auth scope, such as for teams and projects container str The container for which to stream logs. Defaults to only container if there is one container in the pod. [optional] follow bool Follow the log stream of the pod. Defaults to false. [optional] insecure_skip_tls_verify_backend bool insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the serving certificate of the backend it is connecting to. This will make the HTTPS connection between the apiserver and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real kubelet. If the kubelet is configured to verify the apiserver's TLS credentials, it does not mean the connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept the actual log data coming from the real kubelet). [optional] limit_bytes int If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit. [optional] pretty str If 'true', then the output is pretty printed. [optional] previous bool Return previous terminated container logs. Defaults to false. [optional] since_seconds int A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified. [optional] tail_lines int If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime [optional] timestamps bool If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false. [optional]","title":"Parameters"},{"location":"#return-type_158","text":"str","title":"Return type"},{"location":"#authorization_158","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_158","text":"Content-Type : Not defined Accept : text/plain, application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_158","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#read_namespaced_pod_status","text":"V1Pod read_namespaced_pod_status(name, namespace, pretty=pretty) read status of the specified Pod","title":"read_namespaced_pod_status"},{"location":"#example_159","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Pod namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) try: api_response = api_instance.read_namespaced_pod_status(name, namespace, pretty=pretty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_pod_status: %s\\n\" % e)","title":"Example"},{"location":"#parameters_159","text":"Name Type Description Notes name str name of the Pod namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional]","title":"Parameters"},{"location":"#return-type_159","text":"V1Pod","title":"Return type"},{"location":"#authorization_159","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_159","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_159","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#read_namespaced_pod_template","text":"V1PodTemplate read_namespaced_pod_template(name, namespace, pretty=pretty, exact=exact, export=export) read the specified PodTemplate","title":"read_namespaced_pod_template"},{"location":"#example_160","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodTemplate namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) exact = True # bool | Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. (optional) export = True # bool | Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional) try: api_response = api_instance.read_namespaced_pod_template(name, namespace, pretty=pretty, exact=exact, export=export) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_pod_template: %s\\n\" % e)","title":"Example"},{"location":"#parameters_160","text":"Name Type Description Notes name str name of the PodTemplate namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] exact bool Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. [optional] export bool Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. [optional]","title":"Parameters"},{"location":"#return-type_160","text":"V1PodTemplate","title":"Return type"},{"location":"#authorization_160","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_160","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_160","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#read_namespaced_replication_controller","text":"V1ReplicationController read_namespaced_replication_controller(name, namespace, pretty=pretty, exact=exact, export=export) read the specified ReplicationController","title":"read_namespaced_replication_controller"},{"location":"#example_161","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ReplicationController namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) exact = True # bool | Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. (optional) export = True # bool | Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional) try: api_response = api_instance.read_namespaced_replication_controller(name, namespace, pretty=pretty, exact=exact, export=export) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_replication_controller: %s\\n\" % e)","title":"Example"},{"location":"#parameters_161","text":"Name Type Description Notes name str name of the ReplicationController namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] exact bool Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. [optional] export bool Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. [optional]","title":"Parameters"},{"location":"#return-type_161","text":"V1ReplicationController","title":"Return type"},{"location":"#authorization_161","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_161","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_161","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#read_namespaced_replication_controller_scale","text":"V1Scale read_namespaced_replication_controller_scale(name, namespace, pretty=pretty) read scale of the specified ReplicationController","title":"read_namespaced_replication_controller_scale"},{"location":"#example_162","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Scale namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) try: api_response = api_instance.read_namespaced_replication_controller_scale(name, namespace, pretty=pretty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_replication_controller_scale: %s\\n\" % e)","title":"Example"},{"location":"#parameters_162","text":"Name Type Description Notes name str name of the Scale namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional]","title":"Parameters"},{"location":"#return-type_162","text":"V1Scale","title":"Return type"},{"location":"#authorization_162","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_162","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_162","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#read_namespaced_replication_controller_status","text":"V1ReplicationController read_namespaced_replication_controller_status(name, namespace, pretty=pretty) read status of the specified ReplicationController","title":"read_namespaced_replication_controller_status"},{"location":"#example_163","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ReplicationController namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) try: api_response = api_instance.read_namespaced_replication_controller_status(name, namespace, pretty=pretty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_replication_controller_status: %s\\n\" % e)","title":"Example"},{"location":"#parameters_163","text":"Name Type Description Notes name str name of the ReplicationController namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional]","title":"Parameters"},{"location":"#return-type_163","text":"V1ReplicationController","title":"Return type"},{"location":"#authorization_163","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_163","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_163","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#read_namespaced_resource_quota","text":"V1ResourceQuota read_namespaced_resource_quota(name, namespace, pretty=pretty, exact=exact, export=export) read the specified ResourceQuota","title":"read_namespaced_resource_quota"},{"location":"#example_164","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ResourceQuota namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) exact = True # bool | Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. (optional) export = True # bool | Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional) try: api_response = api_instance.read_namespaced_resource_quota(name, namespace, pretty=pretty, exact=exact, export=export) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_resource_quota: %s\\n\" % e)","title":"Example"},{"location":"#parameters_164","text":"Name Type Description Notes name str name of the ResourceQuota namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] exact bool Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. [optional] export bool Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. [optional]","title":"Parameters"},{"location":"#return-type_164","text":"V1ResourceQuota","title":"Return type"},{"location":"#authorization_164","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_164","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_164","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#read_namespaced_resource_quota_status","text":"V1ResourceQuota read_namespaced_resource_quota_status(name, namespace, pretty=pretty) read status of the specified ResourceQuota","title":"read_namespaced_resource_quota_status"},{"location":"#example_165","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ResourceQuota namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) try: api_response = api_instance.read_namespaced_resource_quota_status(name, namespace, pretty=pretty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_resource_quota_status: %s\\n\" % e)","title":"Example"},{"location":"#parameters_165","text":"Name Type Description Notes name str name of the ResourceQuota namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional]","title":"Parameters"},{"location":"#return-type_165","text":"V1ResourceQuota","title":"Return type"},{"location":"#authorization_165","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_165","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_165","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#read_namespaced_secret","text":"V1Secret read_namespaced_secret(name, namespace, pretty=pretty, exact=exact, export=export) read the specified Secret","title":"read_namespaced_secret"},{"location":"#example_166","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Secret namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) exact = True # bool | Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. (optional) export = True # bool | Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional) try: api_response = api_instance.read_namespaced_secret(name, namespace, pretty=pretty, exact=exact, export=export) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_secret: %s\\n\" % e)","title":"Example"},{"location":"#parameters_166","text":"Name Type Description Notes name str name of the Secret namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] exact bool Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. [optional] export bool Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. [optional]","title":"Parameters"},{"location":"#return-type_166","text":"V1Secret","title":"Return type"},{"location":"#authorization_166","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_166","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_166","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#read_namespaced_service","text":"V1Service read_namespaced_service(name, namespace, pretty=pretty, exact=exact, export=export) read the specified Service","title":"read_namespaced_service"},{"location":"#example_167","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Service namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) exact = True # bool | Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. (optional) export = True # bool | Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional) try: api_response = api_instance.read_namespaced_service(name, namespace, pretty=pretty, exact=exact, export=export) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_service: %s\\n\" % e)","title":"Example"},{"location":"#parameters_167","text":"Name Type Description Notes name str name of the Service namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] exact bool Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. [optional] export bool Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. [optional]","title":"Parameters"},{"location":"#return-type_167","text":"V1Service","title":"Return type"},{"location":"#authorization_167","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_167","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_167","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#read_namespaced_service_account","text":"V1ServiceAccount read_namespaced_service_account(name, namespace, pretty=pretty, exact=exact, export=export) read the specified ServiceAccount","title":"read_namespaced_service_account"},{"location":"#example_168","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceAccount namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) exact = True # bool | Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. (optional) export = True # bool | Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional) try: api_response = api_instance.read_namespaced_service_account(name, namespace, pretty=pretty, exact=exact, export=export) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_service_account: %s\\n\" % e)","title":"Example"},{"location":"#parameters_168","text":"Name Type Description Notes name str name of the ServiceAccount namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional] exact bool Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. [optional] export bool Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. [optional]","title":"Parameters"},{"location":"#return-type_168","text":"V1ServiceAccount","title":"Return type"},{"location":"#authorization_168","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_168","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_168","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#read_namespaced_service_status","text":"V1Service read_namespaced_service_status(name, namespace, pretty=pretty) read status of the specified Service","title":"read_namespaced_service_status"},{"location":"#example_169","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Service namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) try: api_response = api_instance.read_namespaced_service_status(name, namespace, pretty=pretty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_namespaced_service_status: %s\\n\" % e)","title":"Example"},{"location":"#parameters_169","text":"Name Type Description Notes name str name of the Service namespace str object name and auth scope, such as for teams and projects pretty str If 'true', then the output is pretty printed. [optional]","title":"Parameters"},{"location":"#return-type_169","text":"V1Service","title":"Return type"},{"location":"#authorization_169","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_169","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_169","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#read_node","text":"V1Node read_node(name, pretty=pretty, exact=exact, export=export) read the specified Node","title":"read_node"},{"location":"#example_170","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Node pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) exact = True # bool | Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. (optional) export = True # bool | Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional) try: api_response = api_instance.read_node(name, pretty=pretty, exact=exact, export=export) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_node: %s\\n\" % e)","title":"Example"},{"location":"#parameters_170","text":"Name Type Description Notes name str name of the Node pretty str If 'true', then the output is pretty printed. [optional] exact bool Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. [optional] export bool Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. [optional]","title":"Parameters"},{"location":"#return-type_170","text":"V1Node","title":"Return type"},{"location":"#authorization_170","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_170","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_170","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#read_node_status","text":"V1Node read_node_status(name, pretty=pretty) read status of the specified Node","title":"read_node_status"},{"location":"#example_171","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Node pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) try: api_response = api_instance.read_node_status(name, pretty=pretty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_node_status: %s\\n\" % e)","title":"Example"},{"location":"#parameters_171","text":"Name Type Description Notes name str name of the Node pretty str If 'true', then the output is pretty printed. [optional]","title":"Parameters"},{"location":"#return-type_171","text":"V1Node","title":"Return type"},{"location":"#authorization_171","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_171","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_171","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#read_persistent_volume","text":"V1PersistentVolume read_persistent_volume(name, pretty=pretty, exact=exact, export=export) read the specified PersistentVolume","title":"read_persistent_volume"},{"location":"#example_172","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PersistentVolume pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) exact = True # bool | Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. (optional) export = True # bool | Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional) try: api_response = api_instance.read_persistent_volume(name, pretty=pretty, exact=exact, export=export) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_persistent_volume: %s\\n\" % e)","title":"Example"},{"location":"#parameters_172","text":"Name Type Description Notes name str name of the PersistentVolume pretty str If 'true', then the output is pretty printed. [optional] exact bool Should the export be exact. Exact export maintains cluster-specific fields like 'Namespace'. Deprecated. Planned for removal in 1.18. [optional] export bool Should this value be exported. Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. [optional]","title":"Parameters"},{"location":"#return-type_172","text":"V1PersistentVolume","title":"Return type"},{"location":"#authorization_172","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_172","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_172","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#read_persistent_volume_status","text":"V1PersistentVolume read_persistent_volume_status(name, pretty=pretty) read status of the specified PersistentVolume","title":"read_persistent_volume_status"},{"location":"#example_173","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PersistentVolume pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) try: api_response = api_instance.read_persistent_volume_status(name, pretty=pretty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->read_persistent_volume_status: %s\\n\" % e)","title":"Example"},{"location":"#parameters_173","text":"Name Type Description Notes name str name of the PersistentVolume pretty str If 'true', then the output is pretty printed. [optional]","title":"Parameters"},{"location":"#return-type_173","text":"V1PersistentVolume","title":"Return type"},{"location":"#authorization_173","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_173","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_173","text":"Status code Description Response headers 200 OK - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#replace_namespace","text":"V1Namespace replace_namespace(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace the specified Namespace","title":"replace_namespace"},{"location":"#example_174","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Namespace body = kubernetes.client.V1Namespace() # V1Namespace | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespace(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespace: %s\\n\" % e)","title":"Example"},{"location":"#parameters_174","text":"Name Type Description Notes name str name of the Namespace body V1Namespace pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_174","text":"V1Namespace","title":"Return type"},{"location":"#authorization_174","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_174","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_174","text":"Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#replace_namespace_finalize","text":"V1Namespace replace_namespace_finalize(name, body, dry_run=dry_run, field_manager=field_manager, pretty=pretty) replace finalize of the specified Namespace","title":"replace_namespace_finalize"},{"location":"#example_175","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Namespace body = kubernetes.client.V1Namespace() # V1Namespace | dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) try: api_response = api_instance.replace_namespace_finalize(name, body, dry_run=dry_run, field_manager=field_manager, pretty=pretty) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespace_finalize: %s\\n\" % e)","title":"Example"},{"location":"#parameters_175","text":"Name Type Description Notes name str name of the Namespace body V1Namespace dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional] pretty str If 'true', then the output is pretty printed. [optional]","title":"Parameters"},{"location":"#return-type_175","text":"V1Namespace","title":"Return type"},{"location":"#authorization_175","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_175","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_175","text":"Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#replace_namespace_status","text":"V1Namespace replace_namespace_status(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace status of the specified Namespace","title":"replace_namespace_status"},{"location":"#example_176","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Namespace body = kubernetes.client.V1Namespace() # V1Namespace | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespace_status(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespace_status: %s\\n\" % e)","title":"Example"},{"location":"#parameters_176","text":"Name Type Description Notes name str name of the Namespace body V1Namespace pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_176","text":"V1Namespace","title":"Return type"},{"location":"#authorization_176","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_176","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_176","text":"Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#replace_namespaced_config_map","text":"V1ConfigMap replace_namespaced_config_map(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace the specified ConfigMap","title":"replace_namespaced_config_map"},{"location":"#example_177","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ConfigMap namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1ConfigMap() # V1ConfigMap | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_config_map(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_config_map: %s\\n\" % e)","title":"Example"},{"location":"#parameters_177","text":"Name Type Description Notes name str name of the ConfigMap namespace str object name and auth scope, such as for teams and projects body V1ConfigMap pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_177","text":"V1ConfigMap","title":"Return type"},{"location":"#authorization_177","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_177","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_177","text":"Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#replace_namespaced_endpoints","text":"V1Endpoints replace_namespaced_endpoints(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace the specified Endpoints","title":"replace_namespaced_endpoints"},{"location":"#example_178","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Endpoints namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1Endpoints() # V1Endpoints | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_endpoints(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_endpoints: %s\\n\" % e)","title":"Example"},{"location":"#parameters_178","text":"Name Type Description Notes name str name of the Endpoints namespace str object name and auth scope, such as for teams and projects body V1Endpoints pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_178","text":"V1Endpoints","title":"Return type"},{"location":"#authorization_178","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_178","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_178","text":"Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#replace_namespaced_event","text":"V1Event replace_namespaced_event(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace the specified Event","title":"replace_namespaced_event"},{"location":"#example_179","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Event namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1Event() # V1Event | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_event(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_event: %s\\n\" % e)","title":"Example"},{"location":"#parameters_179","text":"Name Type Description Notes name str name of the Event namespace str object name and auth scope, such as for teams and projects body V1Event pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_179","text":"V1Event","title":"Return type"},{"location":"#authorization_179","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_179","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_179","text":"Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#replace_namespaced_limit_range","text":"V1LimitRange replace_namespaced_limit_range(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace the specified LimitRange","title":"replace_namespaced_limit_range"},{"location":"#example_180","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the LimitRange namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1LimitRange() # V1LimitRange | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_limit_range(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_limit_range: %s\\n\" % e)","title":"Example"},{"location":"#parameters_180","text":"Name Type Description Notes name str name of the LimitRange namespace str object name and auth scope, such as for teams and projects body V1LimitRange pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_180","text":"V1LimitRange","title":"Return type"},{"location":"#authorization_180","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_180","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_180","text":"Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#replace_namespaced_persistent_volume_claim","text":"V1PersistentVolumeClaim replace_namespaced_persistent_volume_claim(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace the specified PersistentVolumeClaim","title":"replace_namespaced_persistent_volume_claim"},{"location":"#example_181","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PersistentVolumeClaim namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1PersistentVolumeClaim() # V1PersistentVolumeClaim | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_persistent_volume_claim(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_persistent_volume_claim: %s\\n\" % e)","title":"Example"},{"location":"#parameters_181","text":"Name Type Description Notes name str name of the PersistentVolumeClaim namespace str object name and auth scope, such as for teams and projects body V1PersistentVolumeClaim pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_181","text":"V1PersistentVolumeClaim","title":"Return type"},{"location":"#authorization_181","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_181","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_181","text":"Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#replace_namespaced_persistent_volume_claim_status","text":"V1PersistentVolumeClaim replace_namespaced_persistent_volume_claim_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace status of the specified PersistentVolumeClaim","title":"replace_namespaced_persistent_volume_claim_status"},{"location":"#example_182","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PersistentVolumeClaim namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1PersistentVolumeClaim() # V1PersistentVolumeClaim | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_persistent_volume_claim_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_persistent_volume_claim_status: %s\\n\" % e)","title":"Example"},{"location":"#parameters_182","text":"Name Type Description Notes name str name of the PersistentVolumeClaim namespace str object name and auth scope, such as for teams and projects body V1PersistentVolumeClaim pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_182","text":"V1PersistentVolumeClaim","title":"Return type"},{"location":"#authorization_182","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_182","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_182","text":"Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#replace_namespaced_pod","text":"V1Pod replace_namespaced_pod(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace the specified Pod","title":"replace_namespaced_pod"},{"location":"#example_183","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Pod namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1Pod() # V1Pod | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_pod(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_pod: %s\\n\" % e)","title":"Example"},{"location":"#parameters_183","text":"Name Type Description Notes name str name of the Pod namespace str object name and auth scope, such as for teams and projects body V1Pod pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_183","text":"V1Pod","title":"Return type"},{"location":"#authorization_183","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_183","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_183","text":"Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#replace_namespaced_pod_status","text":"V1Pod replace_namespaced_pod_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace status of the specified Pod","title":"replace_namespaced_pod_status"},{"location":"#example_184","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Pod namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1Pod() # V1Pod | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_pod_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_pod_status: %s\\n\" % e)","title":"Example"},{"location":"#parameters_184","text":"Name Type Description Notes name str name of the Pod namespace str object name and auth scope, such as for teams and projects body V1Pod pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_184","text":"V1Pod","title":"Return type"},{"location":"#authorization_184","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_184","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_184","text":"Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#replace_namespaced_pod_template","text":"V1PodTemplate replace_namespaced_pod_template(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace the specified PodTemplate","title":"replace_namespaced_pod_template"},{"location":"#example_185","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PodTemplate namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1PodTemplate() # V1PodTemplate | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_pod_template(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_pod_template: %s\\n\" % e)","title":"Example"},{"location":"#parameters_185","text":"Name Type Description Notes name str name of the PodTemplate namespace str object name and auth scope, such as for teams and projects body V1PodTemplate pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_185","text":"V1PodTemplate","title":"Return type"},{"location":"#authorization_185","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_185","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_185","text":"Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#replace_namespaced_replication_controller","text":"V1ReplicationController replace_namespaced_replication_controller(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace the specified ReplicationController","title":"replace_namespaced_replication_controller"},{"location":"#example_186","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ReplicationController namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1ReplicationController() # V1ReplicationController | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_replication_controller(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_replication_controller: %s\\n\" % e)","title":"Example"},{"location":"#parameters_186","text":"Name Type Description Notes name str name of the ReplicationController namespace str object name and auth scope, such as for teams and projects body V1ReplicationController pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_186","text":"V1ReplicationController","title":"Return type"},{"location":"#authorization_186","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_186","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_186","text":"Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#replace_namespaced_replication_controller_scale","text":"V1Scale replace_namespaced_replication_controller_scale(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace scale of the specified ReplicationController","title":"replace_namespaced_replication_controller_scale"},{"location":"#example_187","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Scale namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1Scale() # V1Scale | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_replication_controller_scale(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_replication_controller_scale: %s\\n\" % e)","title":"Example"},{"location":"#parameters_187","text":"Name Type Description Notes name str name of the Scale namespace str object name and auth scope, such as for teams and projects body V1Scale pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_187","text":"V1Scale","title":"Return type"},{"location":"#authorization_187","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_187","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_187","text":"Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#replace_namespaced_replication_controller_status","text":"V1ReplicationController replace_namespaced_replication_controller_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace status of the specified ReplicationController","title":"replace_namespaced_replication_controller_status"},{"location":"#example_188","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ReplicationController namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1ReplicationController() # V1ReplicationController | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_replication_controller_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_replication_controller_status: %s\\n\" % e)","title":"Example"},{"location":"#parameters_188","text":"Name Type Description Notes name str name of the ReplicationController namespace str object name and auth scope, such as for teams and projects body V1ReplicationController pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_188","text":"V1ReplicationController","title":"Return type"},{"location":"#authorization_188","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_188","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_188","text":"Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#replace_namespaced_resource_quota","text":"V1ResourceQuota replace_namespaced_resource_quota(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace the specified ResourceQuota","title":"replace_namespaced_resource_quota"},{"location":"#example_189","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ResourceQuota namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1ResourceQuota() # V1ResourceQuota | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_resource_quota(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_resource_quota: %s\\n\" % e)","title":"Example"},{"location":"#parameters_189","text":"Name Type Description Notes name str name of the ResourceQuota namespace str object name and auth scope, such as for teams and projects body V1ResourceQuota pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_189","text":"V1ResourceQuota","title":"Return type"},{"location":"#authorization_189","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_189","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_189","text":"Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#replace_namespaced_resource_quota_status","text":"V1ResourceQuota replace_namespaced_resource_quota_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace status of the specified ResourceQuota","title":"replace_namespaced_resource_quota_status"},{"location":"#example_190","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ResourceQuota namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1ResourceQuota() # V1ResourceQuota | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_resource_quota_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_resource_quota_status: %s\\n\" % e)","title":"Example"},{"location":"#parameters_190","text":"Name Type Description Notes name str name of the ResourceQuota namespace str object name and auth scope, such as for teams and projects body V1ResourceQuota pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_190","text":"V1ResourceQuota","title":"Return type"},{"location":"#authorization_190","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_190","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_190","text":"Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#replace_namespaced_secret","text":"V1Secret replace_namespaced_secret(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace the specified Secret","title":"replace_namespaced_secret"},{"location":"#example_191","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Secret namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1Secret() # V1Secret | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_secret(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_secret: %s\\n\" % e)","title":"Example"},{"location":"#parameters_191","text":"Name Type Description Notes name str name of the Secret namespace str object name and auth scope, such as for teams and projects body V1Secret pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_191","text":"V1Secret","title":"Return type"},{"location":"#authorization_191","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_191","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_191","text":"Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#replace_namespaced_service","text":"V1Service replace_namespaced_service(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace the specified Service","title":"replace_namespaced_service"},{"location":"#example_192","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Service namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1Service() # V1Service | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_service(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_service: %s\\n\" % e)","title":"Example"},{"location":"#parameters_192","text":"Name Type Description Notes name str name of the Service namespace str object name and auth scope, such as for teams and projects body V1Service pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_192","text":"V1Service","title":"Return type"},{"location":"#authorization_192","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_192","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_192","text":"Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#replace_namespaced_service_account","text":"V1ServiceAccount replace_namespaced_service_account(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace the specified ServiceAccount","title":"replace_namespaced_service_account"},{"location":"#example_193","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the ServiceAccount namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1ServiceAccount() # V1ServiceAccount | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_service_account(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_service_account: %s\\n\" % e)","title":"Example"},{"location":"#parameters_193","text":"Name Type Description Notes name str name of the ServiceAccount namespace str object name and auth scope, such as for teams and projects body V1ServiceAccount pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_193","text":"V1ServiceAccount","title":"Return type"},{"location":"#authorization_193","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_193","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_193","text":"Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#replace_namespaced_service_status","text":"V1Service replace_namespaced_service_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace status of the specified Service","title":"replace_namespaced_service_status"},{"location":"#example_194","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Service namespace = 'namespace_example' # str | object name and auth scope, such as for teams and projects body = kubernetes.client.V1Service() # V1Service | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_namespaced_service_status(name, namespace, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_namespaced_service_status: %s\\n\" % e)","title":"Example"},{"location":"#parameters_194","text":"Name Type Description Notes name str name of the Service namespace str object name and auth scope, such as for teams and projects body V1Service pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_194","text":"V1Service","title":"Return type"},{"location":"#authorization_194","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_194","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_194","text":"Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#replace_node","text":"V1Node replace_node(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace the specified Node","title":"replace_node"},{"location":"#example_195","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Node body = kubernetes.client.V1Node() # V1Node | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_node(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_node: %s\\n\" % e)","title":"Example"},{"location":"#parameters_195","text":"Name Type Description Notes name str name of the Node body V1Node pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_195","text":"V1Node","title":"Return type"},{"location":"#authorization_195","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_195","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_195","text":"Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#replace_node_status","text":"V1Node replace_node_status(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace status of the specified Node","title":"replace_node_status"},{"location":"#example_196","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the Node body = kubernetes.client.V1Node() # V1Node | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_node_status(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_node_status: %s\\n\" % e)","title":"Example"},{"location":"#parameters_196","text":"Name Type Description Notes name str name of the Node body V1Node pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_196","text":"V1Node","title":"Return type"},{"location":"#authorization_196","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_196","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_196","text":"Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#replace_persistent_volume","text":"V1PersistentVolume replace_persistent_volume(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace the specified PersistentVolume","title":"replace_persistent_volume"},{"location":"#example_197","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PersistentVolume body = kubernetes.client.V1PersistentVolume() # V1PersistentVolume | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_persistent_volume(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_persistent_volume: %s\\n\" % e)","title":"Example"},{"location":"#parameters_197","text":"Name Type Description Notes name str name of the PersistentVolume body V1PersistentVolume pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_197","text":"V1PersistentVolume","title":"Return type"},{"location":"#authorization_197","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_197","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_197","text":"Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"},{"location":"#replace_persistent_volume_status","text":"V1PersistentVolume replace_persistent_volume_status(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) replace status of the specified PersistentVolume","title":"replace_persistent_volume_status"},{"location":"#example_198","text":"Api Key Authentication (BearerToken): from __future__ import print_function import time import kubernetes.client from kubernetes.client.rest import ApiException from pprint import pprint configuration = kubernetes.client.Configuration() # Configure API key authorization: BearerToken configuration.api_key['authorization'] = 'YOUR_API_KEY' # Uncomment below to setup prefix (e.g. Bearer) for API key, if needed # configuration.api_key_prefix['authorization'] = 'Bearer' # Defining host is optional and default to http://localhost configuration.host = \"http://localhost\" # Enter a context with an instance of the API kubernetes.client with kubernetes.client.ApiClient(configuration) as api_client: # Create an instance of the API class api_instance = kubernetes.client.CoreV1Api(api_client) name = 'name_example' # str | name of the PersistentVolume body = kubernetes.client.V1PersistentVolume() # V1PersistentVolume | pretty = 'pretty_example' # str | If 'true', then the output is pretty printed. (optional) dry_run = 'dry_run_example' # str | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional) field_manager = 'field_manager_example' # str | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional) try: api_response = api_instance.replace_persistent_volume_status(name, body, pretty=pretty, dry_run=dry_run, field_manager=field_manager) pprint(api_response) except ApiException as e: print(\"Exception when calling CoreV1Api->replace_persistent_volume_status: %s\\n\" % e)","title":"Example"},{"location":"#parameters_198","text":"Name Type Description Notes name str name of the PersistentVolume body V1PersistentVolume pretty str If 'true', then the output is pretty printed. [optional] dry_run str When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed [optional] field_manager str fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. [optional]","title":"Parameters"},{"location":"#return-type_198","text":"V1PersistentVolume","title":"Return type"},{"location":"#authorization_198","text":"BearerToken","title":"Authorization"},{"location":"#http-request-headers_198","text":"Content-Type : Not defined Accept : application/json, application/yaml, application/vnd.kubernetes.protobuf","title":"HTTP request headers"},{"location":"#http-response-details_198","text":"Status code Description Response headers 200 OK - 201 Created - 401 Unauthorized - [Back to top] [Back to API list] [Back to Model list] [Back to README]","title":"HTTP response details"}]}